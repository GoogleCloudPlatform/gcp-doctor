{
  "id": "projects/gcpd-gce1-4exv/zones/europe-west1-b/instances",
  "items": [
    {
      "canIpForward": true,
      "cpuPlatform": "Intel Haswell",
      "creationTimestamp": "2021-06-25T07:36:06.926-07:00",
      "deletionProtection": false,
      "disks": [
        {
          "autoDelete": true,
          "boot": true,
          "deviceName": "persistent-disk-0",
          "diskSizeGb": "100",
          "guestOsFeatures": [
            {
              "type": "SEV_CAPABLE"
            },
            {
              "type": "UEFI_COMPATIBLE"
            },
            {
              "type": "SECURE_BOOT"
            },
            {
              "type": "VIRTIO_SCSI_MULTIQUEUE"
            }
          ],
          "index": 0,
          "interface": "SCSI",
          "kind": "compute#attachedDisk",
          "licenses": [
            "https://www.googleapis.com/compute/v1/projects/cos-cloud-shielded/global/licenses/shielded-cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos-pcid",
            "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/licenses/gke-node"
          ],
          "mode": "READ_WRITE",
          "shieldedInstanceInitialState": {
            "dbs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "dbxs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "keks": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "pk": {
              "content": "REDACTED",
              "fileType": "X509"
            }
          },
          "source": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/disks/gke-gke1-default-pool-564e261a-2j8p",
          "type": "PERSISTENT"
        }
      ],
      "fingerprint": "H9euBd6ztIk=",
      "id": "249012195448870713",
      "kind": "compute#instance",
      "labelFingerprint": "mUgogP08_Iw=",
      "labels": {
        "gcp_doctor_test": "gke",
        "goog-gke-node": ""
      },
      "lastStartTimestamp": "2021-06-25T07:36:16.482-07:00",
      "machineType": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/machineTypes/e2-small",
      "metadata": {
        "fingerprint": "ZvGGNwyPIKs=",
        "items": [
          {
            "key": "instance-template",
            "value": "projects/50670056743/global/instanceTemplates/gke-gke1-default-pool-564e261a"
          },
          {
            "key": "created-by",
            "value": "projects/50670056743/zones/europe-west1-b/instanceGroupManagers/gke-gke1-default-pool-564e261a-grp"
          },
          {
            "key": "serial-port-logging-enable",
            "value": "true"
          },
          {
            "key": "kube-labels",
            "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
          },
          {
            "key": "google-compute-enable-pcid",
            "value": "true"
          },
          {
            "key": "enable-oslogin",
            "value": "false"
          },
          {
            "key": "kubelet-config",
            "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.3.240.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 512Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
          },
          {
            "key": "cluster-name",
            "value": "gke1"
          },
          {
            "key": "gci-update-strategy",
            "value": "update_disabled"
          },
          {
            "key": "gci-metrics-enabled",
            "value": "true"
          },
          {
            "key": "configure-sh",
            "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION=\"v0.8.7\"\nDEFAULT_CNI_HASH=\"8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede\"\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION=\"v0.8.7\"\nDEFAULT_NPD_HASH=\"853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea\"\nDEFAULT_CRICTL_VERSION=\"v1.18.0\"\nDEFAULT_CRICTL_HASH=\"9fe9f80f96542e90b47ae13726fd1cf6ed329117c64cefc1c0dda81b65a46551a6d273810efc689993eff41f2091536af9b536a2d0c6a51ec2e6480db26b6b8b\"\nDEFAULT_MOUNTER_TAR_SHA=\"7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516\"\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Use --retry-connrefused opt only if it's supported by curl.\nCURL_RETRY_CONNREFUSED=\"\"\nif curl --help | grep -q -- '--retry-connrefused'; then\n  CURL_RETRY_CONNREFUSED='--retry-connrefused'\nfi\n\nfunction set-broken-motd {\n  cat > /etc/motd <<EOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes to STDOUT.\n#\n# $1: URL path after /computeMetadata/v1/ (without heading slash).\nfunction get-metadata-value {\n    curl \\\n        --retry 5 \\\n        --retry-delay 3 \\\n        ${CURL_RETRY_CONNREFUSED} \\\n        --fail \\\n        --silent \\\n        -H 'Metadata-Flavor: Google' \\\n        \"http://metadata/computeMetadata/v1/${1}\"\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${kube_env_path}\" > \"${KUBE_HOME}/kube-env\")\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    $kube_env_hms_path\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    if curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${tmp_kubelet_config}\" \\\n        http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config; then\n      # only write to the final location if curl succeeds\n      mv \"${tmp_kubelet_config}\" \"${dest}\"\n    elif [[ \"${REQUIRE_METADATA_KUBELET_CONFIG_FILE:-false}\" == \"true\" ]]; then\n      echo \"== Failed to download required Kubelet config file from metadata server ==\"\n      exit 1\n    fi\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${tmp_kube_master_certs}\" > \"${KUBE_HOME}/kube-master-certs\")\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" -H \"Metadata-Flavor: Google\" -s | ${PYTHON} -c \\\n    'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" -H \"Metadata-Flavor: Google\" -s | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  local -r urls=( $* )\n  while true; do\n    for url in \"${urls[@]}\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 ${CURL_RETRY_CONNREFUSED} \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo $1 | tr \",\" \"\\n\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p $flexvolume_plugin_dir\n  mount --bind $flexvolume_plugin_dir $flexvolume_plugin_dir\n  mount -o remount,exec $flexvolume_plugin_dir\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"https://storage.googleapis.com/kubernetes-release\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_version=\"${CNI_VERSION}\"\n      local -r cni_hash=\"${CNI_HASH}\"\n  else\n      local -r cni_version=\"${DEFAULT_CNI_VERSION}\"\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-linux-amd64.tar.gz\"\n\n  # Create crictl config file.\n  cat > /etc/crictl.yaml <<EOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local -r manifests_tar_urls=( $(split-commas \"${KUBE_MANIFESTS_TAR_URL}\") )\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" -name \\*.yaml -or -name \\*.yaml.in | \\\n      xargs sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" -name \\*.manifest -or -name \\*.json | \\\n      xargs sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat > \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" <<EOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get >/dev/null 2>&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends ${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n    echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # containerd versions have slightly different url(s), so try both\n    ( curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-linux-amd64.tar.gz\" || \\\n      curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.linux-amd64.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    curl -fsSL \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.amd64\" --output /usr/sbin/runc && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker >/dev/null 2>&1; then\n      install-docker\n      if ! command -v docker >/dev/null 2>&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr >/dev/null 2>&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd >/dev/null 2>&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc >/dev/null 2>&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local -r server_binary_tar_urls=( $(split-commas \"${SERVER_BINARY_TAR_URL}\") )\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO(awly): include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# retry-forever retries a command forever with a delay between retries.\n#\n# $1:     Delay between retries, in seconds.\n# $2..$N: Command to retry.\n#\n# e.g.: `retry-forever 30 do something` retries `do something` every 30s.\nfunction retry-forever {\n  local -r delay=$1\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $@ failed, retrying after ${delay}s ==\"\n    sleep ${delay}\n  done\n}\n\n######### Main Function ##########\necho \"Start to install kubernetes files\"\n# if install fails, message-of-the-day (motd) will warn at login shell\nset-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nif [[ \"$(python -V 2>&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} >/dev/null 2>&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version : \" $(${PYTHON} -V 2>&1)\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  install-hurl\n  install-inplace\nfi\n\n# download and source kube-env\nretry-forever 30 download-kube-env\nsource \"${KUBE_HOME}/kube-env\"\n\nretry-forever 10 download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 10 download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nensure-container-runtime\n\n# binaries and kube-system manifests\ninstall-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 30 inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\n"
          },
          {
            "key": "gci-ensure-gke-docker",
            "value": "true"
          },
          {
            "key": "disable-legacy-endpoints",
            "value": "true"
          },
          {
            "key": "user-data",
            "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      # Use --retry-connrefused opt only if it's supported by curl.\n      ExecStartPre=/bin/bash -c 'OPT=\"\"; if curl --help | grep -q -- \"--retry-connrefused\"; then OPT=\"--retry-connrefused\"; fi; /usr/bin/curl --fail --retry 5 --retry-delay 3 $OPT --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh'\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
          },
          {
            "key": "kube-env",
            "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=512Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURLakNDQWhLZ0F3SUJBZ0lRRUxqNjFNckxxNnE0L3JJY2FDeXA1VEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVE16TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBdk1TMHdLd1lEVlFRREV5UmxNMkl6Ck56aGxOUzFtTUdNMUxUUmlPVFF0WVRaaE9DMWpNbVZtT1dVNFlXVXpPR013Z2dFaU1BMEdDU3FHU0liM0RRRUIKQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUM4cUEwZlEvWW1tMUE2ZlBEbFFyM3MybWg3dmVleDcrM091ekxKc3VHRQpxQSsrb0lXb0w2ZGx2WEZIaWFmZUJkbGxNTCsrRngvc2diSU1GWkZCS1FBeXVoYWowaWdzdEN3dnBnSURwWmRICi8yVVZZbUNoZnhYY3ZFS01EOE84eXpENmgrd3RBODBFV2hYRHBVbU5yWHpXOE5YMWh6eDFGRUwzN3daYlIzUnYKaFNINUcrSldTNHQ1YjJBMi9UU1BYb2ovUWFrUFI4K01EV0VnejQ5cXdNRzFKQnMyeG1oYnp0TXFwSzhDR3RWWApZWjI4QXJmczJQanp2dUMrLzkzdjFHM1FETzdNTUU2NGFxZ3FwdGJjOGtnQzBXZXc1RWo4VWxkd1BFdXlqdVZ5CmRpSDd5OXJXR1Fvb3pJMEREZjNQMEpDVTduVkNuL3Y4czlPQjkrMnFuSFB2QWdNQkFBR2pRakJBTUE0R0ExVWQKRHdFQi93UUVBd0lDQkRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJUU1NWSFBEWXRhejJFZwo0SkVvMllZQVZWS2g3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBbGVOYjhYdThhZGFpWit1dVkvOU9PWEpiCmZyeTcxTzdKTlRCd1hxYUNlVkplWlpkRXBjcXlsREJNVHVHNWRXdnpuang2NldSZU5uQnFhYWhiT2lZTG5ZYk8KUFdwNERRUURRRk40djcvdTVBZUZya0pFY2ZlZUFhTnRmYW5SSHNIWU9KNFdLOXlPU1BUbGl0Y09wUG9wTnZBQwpwd0JUbWl1YTdOemRTTWNEc2tTeDdRdVFtQ21GWGFuQm5jOHhKaUtUUVc0RnRnYWhidWdlbmR1bWtoSHQrRWo2CjhRTWY1dmM5am5URFVvaVl2VDVLR2NPTG4rQm1sSWxCeGlEMWZacEYyQzFRMHIwU3d1bU9VakwrWDdvUk50YysKWXJOTTZZVm9UWXJ4N1F1T1l2bkc3ZGdXeHlvaElOMi9ibTdiek9LV21NSWUrWkN1SDgzcTdDaHMrUWdlR3c9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nCLUSTER_IP_RANGE: 10.0.0.0/14\nCLUSTER_NAME: gke1\nCNI_HASH: 60bec898cffa83ee33023df0ea6001940f222e38d360e6829d05b821cff9921842418441abe8cbb9eada606edf50f0fe5730209311b8be5e035db022db4e3a5f\nCNI_SHA1: dcbeba8d6be7a49e399bda6b8b638d312eace876\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v0.8.5-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v0.8.5-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"true\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.3.240.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-06-25T14:35:31+00:00\"\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nFEATURE_GATES: DynamicKubeletConfig=false,RotateKubeletServerCertificate=true\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke1-47424322\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.3.240.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: 2d81bbf4be92bbb6fa787430dff367810a7653b29ec4a0b328fd03f085d65d2dd5f6db8d66308a227036e5a302d7ace428a421c2348edde07e01ef1f789d1c55\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: bq0FV20sBVb3n8atkvcB93Ki6N9CATMIIm51JMj2kGE=\nKUBELET_ARGS: --v=2 --cloud-provider=gce --experimental-check-node-capabilities-before-mount=true\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --bootstrap-kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig --node-status-max-images=25\n  --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBELET_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lRUHpnQzgzRnJkYmI3Ylk2L0RyZUtSakFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVFF6TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBU01SQXdEZ1lEVlFRREV3ZHJkV0psCmJHVjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXZvQyszMjVrTEdCdXZVb2EKcHE2L2c5VGwySmdiUXdkSE00QnB5RzZSVjJDUEZZQTAySmlES0RVcS82aDd0Zm5rZXZ2RXorTTZHTlJzMVQ5QQpKUi95S0hXSEZ4bTU1LzB4NHdCb3lERDlRek1sQWVkbWtLVHdQNXRDNzFCMzVrdkNVN2dOVmtLTUJCd0xpajVSCmYxMDI3NFhrVDR5VTZMdzBJMWZTREFyWmlYYWE5RnB1RmFxZ1JsMC9OdmVRcWsvVU95b1hlN2poUVdDaG1oT2oKcDRraGNrK2VpQzY2VXpwbjFCclBSamNlNDU1YlJkMTNQUjdIN3FNcXkzRTNzaThXNVRTRUswSVpUWlkxeGNLegpEVHBXNWxjVWRBN1RlSlpjNVBKZW9lUTZxemZDZ0dTVmFRcDVIUEVHd2pSS01RVkRXY1psVFdPMmdWYVN0ejlYCjJ1NThGd0lEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JUU1NWSFBEWXRhejJFZzRKRW8yWVlBVlZLaAo3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBTzZieno2NC9vRUFhTzRxUm1WM0hOMUZOZEd5YkE4SkZUQjg0CmtISUZ0cTYyVWJpb1oreStMci9XSVZXMTVkMzgrMmNlV2l1ZUl0L09qbkZtVFowUjZSWjRxT0dlUUZOM0NQeW0KQWpHT1hsTElvOFl6cEVFZXg3OGZITjFhSml3MGxxVk1FR0ZHZGJkTzlKMS80cjQzdmNBVmVSRkZHcm1vZXBQQwpMU294clJ4aVFoSi9NRlpjTnBqbFRmUzhpcG5reG5xaW1IOEdYTzZaMGlEa0VGQ2xjZVJicG9sc05qTDRtNnhxCmlmSEVHT1NRRk81OHRocFNxa29ZRXFRUkUva3BpN1Q3WnhFZFRzM3ZMdVVKK0ZhYTcxSGlFTjJHc2pEdE9WUWkKVjdDdW0vc21hSTMrZC9SaGtrUGpORWwwSU8wbmhUNUh3enVQTXB0OEFxbGZ2QUg2SUE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nKUBELET_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBdm9DKzMyNWtMR0J1dlVvYXBxNi9nOVRsMkpnYlF3ZEhNNEJweUc2UlYyQ1BGWUEwCjJKaURLRFVxLzZoN3RmbmtldnZFeitNNkdOUnMxVDlBSlIveUtIV0hGeG01NS8weDR3Qm95REQ5UXpNbEFlZG0Ka0tUd1A1dEM3MUIzNWt2Q1U3Z05Wa0tNQkJ3TGlqNVJmMTAyNzRYa1Q0eVU2THcwSTFmU0RBclppWGFhOUZwdQpGYXFnUmwwL052ZVFxay9VT3lvWGU3amhRV0NobWhPanA0a2hjaytlaUM2NlV6cG4xQnJQUmpjZTQ1NWJSZDEzClBSN0g3cU1xeTNFM3NpOFc1VFNFSzBJWlRaWTF4Y0t6RFRwVzVsY1VkQTdUZUpaYzVQSmVvZVE2cXpmQ2dHU1YKYVFwNUhQRUd3alJLTVFWRFdjWmxUV08yZ1ZhU3R6OVgydTU4RndJREFRQUJBb0lCQUJ0Y0dZMjBxTFc5alI5VQplRUFUZllxWDFnR1FmdXlCTEJjQ2QxbURsUTRyM2xZNUxvaDVCdS9odFp1TmZXUlBwU0tMUVkzckt0bmhaYXdPCnhIaWwwNUtVcG8wenlGWnEybkpVQ2JoNVhndW1XY2RNamtJY2lOWC9ITkxnQjEyazZIT1ErSGE0dDFhVHdlTXoKTzJNdVpsMi9mZ3NnRVV3eVUzbEwrMEo0S3h2L0ZENjVERWkyRTBzQzVMWjIvYnN6NUdiV3JFVVNHQTdSQk9URwoySlR1U205WDVYYk00UGNoSkVidElUOTRmdGx5QTlIdW9VdFRTQ0Z4Q29MWHRQNzh3RTlCVG5pNHRpV20vL0xaCm1sT2FLemNmR2dEbVpXbHowSi93b2E2UFNMVTBuUkcvWllBem5Dd1JzcWJXaDRWMTd0eVZ6UDRMNGJHblgwQUEKVnFpTTBsa0NnWUVBNkFIajdEQVB6aHdYQ3lUaXFlQkFqNkZFRWs0bzNyWmhrN1lFTTdyVEM0NENxczNRaWVrNwplcVVtMVB6MXJRei9DVjBUSFBQTTBMb3EwVDQvSUlvL2k0cGlEVDd2dkZ5aGVIOW52ZGJxL3hyK1YrNE9JaFlCCmtRS1VzZ0UydnpiYmZkbWh5MmZab3V4R3RJdnpkcEpXUFp2eUFjM2ZhR2FINFJLajNYb1h2YXNDZ1lFQTBqUVQKVlR3VG9zMG1xMzBteUp5cXNLMDNaUThsRnZaWW03TVhtdWQwMWZWYW9RYXJDamZnR1lZaGZuSGNWdlY4c3NPZAp2Y0NEMFNBdlBlNGtqeUxpT2lyaHdlaUNUSmdjOVZ5bTZ3WjdVK0VCaTAydW90UTZXY2prYURwRzJ3WjZ1UXp4CkIxSVlBelpNaFllYmowVkoyRWRxekVuWlRFYms1a0w4U1VkNkYwVUNnWUVBallsaHI1d2VlRUhndVBhMnBLWGYKSFFCbjA3Y0U3ZUZibzg0OXdBVXdiUE1rbzJqTjJPU0ZXYXZaQmNTUWFCTHVuNXE5WjBOQVp2RzczMHpYSEJYYQo4RmpxdW1Qend2akx0UVFjbU02OUxBWWV0aXZQU1hJZFlJYXZpZXg5cHFkanZlSC85MlFTZkhjaUoxRGRwUzlmCkYxVEVqZDgzZEt4Z0pxbkZkLzdjN3VNQ2dZRUF2c2VHMkhBN1BpSkdPNVRPRTN1bHE4NjZuUjArdzNWNGZHL3kKTjZSa3RTQUhUbWkzNmdGR2dzUHJPRkRzODN2QTNwcU9XejhVSkVTNnU5R2RHdEJGVlJmQWFIYTNjLzhISVdZagpGT0tBSW1Qd085ZVliYTZDK3lSS3NaSmE1c1VkczBCY3JoRkRPLzhYT29ZV21OVUJMYXU3OFlnQkVhcXlhNDVXClhjZml0cVVDZ1lFQXhwcG15VkpIcXhha0tuRWNURUgzc0hBMDBqbThTOC9raHRiUEVzdmdnNEkvaGsxWmtBSjkKbHFlUnZCQTdWdVZUTnd0Z0haZEhNcEtxNUFtKzBOZnB5cTN5MTltWEhCTHFad1hsYXIxVThMaDNtYXowWHlMago0WUhNcTdRLzV5anZ4NDF2azRtVU9jbVRUajRRMFExcE1JOWoyTzFSbUthY1d5VGxoK1pCb2ZNPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.78.155.57\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNODE_PROBLEM_DETECTOR_TOKEN: xDTwsYAE0JID1zZ92PFXELKbSKPkUFzuWb5vZbbRP8Y=\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: 547a4d625e71f6c905e8c552e4cacff0d8f60a5447ff98e3b6776e6500930ed888578151b09f878da9243b8a8f95e95aeb77abb9645c5776f01fdf49272bcaad\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.3.240.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1-b\n"
          },
          {
            "key": "cluster-uid",
            "value": "47424322166c49519dbdb364888d425f4ea5b7c7d3354c138a45e732e6e4c39a"
          },
          {
            "key": "cluster-location",
            "value": "europe-west1-b"
          }
        ],
        "kind": "compute#metadata"
      },
      "name": "gke-gke1-default-pool-564e261a-2j8p",
      "networkInterfaces": [
        {
          "accessConfigs": [
            {
              "kind": "compute#accessConfig",
              "name": "external-nat",
              "natIP": "34.79.192.210",
              "networkTier": "PREMIUM",
              "type": "ONE_TO_ONE_NAT"
            }
          ],
          "fingerprint": "B0SbQpgTy_w=",
          "kind": "compute#networkInterface",
          "name": "nic0",
          "network": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/global/networks/default",
          "networkIP": "10.132.0.12",
          "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/regions/europe-west1/subnetworks/default"
        }
      ],
      "scheduling": {
        "automaticRestart": true,
        "onHostMaintenance": "MIGRATE",
        "preemptible": false
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/instances/gke-gke1-default-pool-564e261a-2j8p",
      "serviceAccounts": [
        {
          "email": "50670056743-compute@developer.gserviceaccount.com",
          "scopes": [
            "https://www.googleapis.com/auth/logging.write",
            "https://www.googleapis.com/auth/monitoring"
          ]
        }
      ],
      "shieldedInstanceConfig": {
        "enableIntegrityMonitoring": true,
        "enableSecureBoot": false,
        "enableVtpm": true
      },
      "shieldedInstanceIntegrityPolicy": {
        "updateAutoLearnPolicy": true
      },
      "startRestricted": false,
      "status": "RUNNING",
      "tags": {
        "fingerprint": "pCLl13iJLH4=",
        "items": [
          "gke-gke1-47424322-node"
        ]
      },
      "zone": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b"
    },
    {
      "canIpForward": true,
      "cpuPlatform": "Intel Haswell",
      "creationTimestamp": "2021-06-25T07:36:06.957-07:00",
      "deletionProtection": false,
      "disks": [
        {
          "autoDelete": true,
          "boot": true,
          "deviceName": "persistent-disk-0",
          "diskSizeGb": "100",
          "guestOsFeatures": [
            {
              "type": "SEV_CAPABLE"
            },
            {
              "type": "UEFI_COMPATIBLE"
            },
            {
              "type": "SECURE_BOOT"
            },
            {
              "type": "VIRTIO_SCSI_MULTIQUEUE"
            }
          ],
          "index": 0,
          "interface": "SCSI",
          "kind": "compute#attachedDisk",
          "licenses": [
            "https://www.googleapis.com/compute/v1/projects/cos-cloud-shielded/global/licenses/shielded-cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos-pcid",
            "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/licenses/gke-node"
          ],
          "mode": "READ_WRITE",
          "shieldedInstanceInitialState": {
            "dbs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "dbxs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "keks": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "pk": {
              "content": "REDACTED",
              "fileType": "X509"
            }
          },
          "source": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/disks/gke-gke1-default-pool-564e261a-dgx7",
          "type": "PERSISTENT"
        }
      ],
      "fingerprint": "IF71jbuqqWo=",
      "id": "6894766348412933945",
      "kind": "compute#instance",
      "labelFingerprint": "mUgogP08_Iw=",
      "labels": {
        "gcp_doctor_test": "gke",
        "goog-gke-node": ""
      },
      "lastStartTimestamp": "2021-06-25T07:36:16.113-07:00",
      "machineType": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/machineTypes/e2-small",
      "metadata": {
        "fingerprint": "ZvGGNwyPIKs=",
        "items": [
          {
            "key": "instance-template",
            "value": "projects/50670056743/global/instanceTemplates/gke-gke1-default-pool-564e261a"
          },
          {
            "key": "created-by",
            "value": "projects/50670056743/zones/europe-west1-b/instanceGroupManagers/gke-gke1-default-pool-564e261a-grp"
          },
          {
            "key": "serial-port-logging-enable",
            "value": "true"
          },
          {
            "key": "kube-labels",
            "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
          },
          {
            "key": "google-compute-enable-pcid",
            "value": "true"
          },
          {
            "key": "enable-oslogin",
            "value": "false"
          },
          {
            "key": "kubelet-config",
            "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.3.240.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 512Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
          },
          {
            "key": "cluster-name",
            "value": "gke1"
          },
          {
            "key": "gci-update-strategy",
            "value": "update_disabled"
          },
          {
            "key": "gci-metrics-enabled",
            "value": "true"
          },
          {
            "key": "configure-sh",
            "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION=\"v0.8.7\"\nDEFAULT_CNI_HASH=\"8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede\"\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION=\"v0.8.7\"\nDEFAULT_NPD_HASH=\"853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea\"\nDEFAULT_CRICTL_VERSION=\"v1.18.0\"\nDEFAULT_CRICTL_HASH=\"9fe9f80f96542e90b47ae13726fd1cf6ed329117c64cefc1c0dda81b65a46551a6d273810efc689993eff41f2091536af9b536a2d0c6a51ec2e6480db26b6b8b\"\nDEFAULT_MOUNTER_TAR_SHA=\"7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516\"\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Use --retry-connrefused opt only if it's supported by curl.\nCURL_RETRY_CONNREFUSED=\"\"\nif curl --help | grep -q -- '--retry-connrefused'; then\n  CURL_RETRY_CONNREFUSED='--retry-connrefused'\nfi\n\nfunction set-broken-motd {\n  cat > /etc/motd <<EOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes to STDOUT.\n#\n# $1: URL path after /computeMetadata/v1/ (without heading slash).\nfunction get-metadata-value {\n    curl \\\n        --retry 5 \\\n        --retry-delay 3 \\\n        ${CURL_RETRY_CONNREFUSED} \\\n        --fail \\\n        --silent \\\n        -H 'Metadata-Flavor: Google' \\\n        \"http://metadata/computeMetadata/v1/${1}\"\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${kube_env_path}\" > \"${KUBE_HOME}/kube-env\")\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    $kube_env_hms_path\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    if curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${tmp_kubelet_config}\" \\\n        http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config; then\n      # only write to the final location if curl succeeds\n      mv \"${tmp_kubelet_config}\" \"${dest}\"\n    elif [[ \"${REQUIRE_METADATA_KUBELET_CONFIG_FILE:-false}\" == \"true\" ]]; then\n      echo \"== Failed to download required Kubelet config file from metadata server ==\"\n      exit 1\n    fi\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${tmp_kube_master_certs}\" > \"${KUBE_HOME}/kube-master-certs\")\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" -H \"Metadata-Flavor: Google\" -s | ${PYTHON} -c \\\n    'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" -H \"Metadata-Flavor: Google\" -s | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  local -r urls=( $* )\n  while true; do\n    for url in \"${urls[@]}\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 ${CURL_RETRY_CONNREFUSED} \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo $1 | tr \",\" \"\\n\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p $flexvolume_plugin_dir\n  mount --bind $flexvolume_plugin_dir $flexvolume_plugin_dir\n  mount -o remount,exec $flexvolume_plugin_dir\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"https://storage.googleapis.com/kubernetes-release\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_version=\"${CNI_VERSION}\"\n      local -r cni_hash=\"${CNI_HASH}\"\n  else\n      local -r cni_version=\"${DEFAULT_CNI_VERSION}\"\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-linux-amd64.tar.gz\"\n\n  # Create crictl config file.\n  cat > /etc/crictl.yaml <<EOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local -r manifests_tar_urls=( $(split-commas \"${KUBE_MANIFESTS_TAR_URL}\") )\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" -name \\*.yaml -or -name \\*.yaml.in | \\\n      xargs sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" -name \\*.manifest -or -name \\*.json | \\\n      xargs sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat > \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" <<EOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get >/dev/null 2>&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends ${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n    echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # containerd versions have slightly different url(s), so try both\n    ( curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-linux-amd64.tar.gz\" || \\\n      curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.linux-amd64.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    curl -fsSL \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.amd64\" --output /usr/sbin/runc && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker >/dev/null 2>&1; then\n      install-docker\n      if ! command -v docker >/dev/null 2>&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr >/dev/null 2>&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd >/dev/null 2>&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc >/dev/null 2>&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local -r server_binary_tar_urls=( $(split-commas \"${SERVER_BINARY_TAR_URL}\") )\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO(awly): include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# retry-forever retries a command forever with a delay between retries.\n#\n# $1:     Delay between retries, in seconds.\n# $2..$N: Command to retry.\n#\n# e.g.: `retry-forever 30 do something` retries `do something` every 30s.\nfunction retry-forever {\n  local -r delay=$1\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $@ failed, retrying after ${delay}s ==\"\n    sleep ${delay}\n  done\n}\n\n######### Main Function ##########\necho \"Start to install kubernetes files\"\n# if install fails, message-of-the-day (motd) will warn at login shell\nset-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nif [[ \"$(python -V 2>&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} >/dev/null 2>&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version : \" $(${PYTHON} -V 2>&1)\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  install-hurl\n  install-inplace\nfi\n\n# download and source kube-env\nretry-forever 30 download-kube-env\nsource \"${KUBE_HOME}/kube-env\"\n\nretry-forever 10 download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 10 download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nensure-container-runtime\n\n# binaries and kube-system manifests\ninstall-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 30 inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\n"
          },
          {
            "key": "gci-ensure-gke-docker",
            "value": "true"
          },
          {
            "key": "disable-legacy-endpoints",
            "value": "true"
          },
          {
            "key": "user-data",
            "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      # Use --retry-connrefused opt only if it's supported by curl.\n      ExecStartPre=/bin/bash -c 'OPT=\"\"; if curl --help | grep -q -- \"--retry-connrefused\"; then OPT=\"--retry-connrefused\"; fi; /usr/bin/curl --fail --retry 5 --retry-delay 3 $OPT --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh'\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
          },
          {
            "key": "kube-env",
            "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=512Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURLakNDQWhLZ0F3SUJBZ0lRRUxqNjFNckxxNnE0L3JJY2FDeXA1VEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVE16TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBdk1TMHdLd1lEVlFRREV5UmxNMkl6Ck56aGxOUzFtTUdNMUxUUmlPVFF0WVRaaE9DMWpNbVZtT1dVNFlXVXpPR013Z2dFaU1BMEdDU3FHU0liM0RRRUIKQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUM4cUEwZlEvWW1tMUE2ZlBEbFFyM3MybWg3dmVleDcrM091ekxKc3VHRQpxQSsrb0lXb0w2ZGx2WEZIaWFmZUJkbGxNTCsrRngvc2diSU1GWkZCS1FBeXVoYWowaWdzdEN3dnBnSURwWmRICi8yVVZZbUNoZnhYY3ZFS01EOE84eXpENmgrd3RBODBFV2hYRHBVbU5yWHpXOE5YMWh6eDFGRUwzN3daYlIzUnYKaFNINUcrSldTNHQ1YjJBMi9UU1BYb2ovUWFrUFI4K01EV0VnejQ5cXdNRzFKQnMyeG1oYnp0TXFwSzhDR3RWWApZWjI4QXJmczJQanp2dUMrLzkzdjFHM1FETzdNTUU2NGFxZ3FwdGJjOGtnQzBXZXc1RWo4VWxkd1BFdXlqdVZ5CmRpSDd5OXJXR1Fvb3pJMEREZjNQMEpDVTduVkNuL3Y4czlPQjkrMnFuSFB2QWdNQkFBR2pRakJBTUE0R0ExVWQKRHdFQi93UUVBd0lDQkRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJUU1NWSFBEWXRhejJFZwo0SkVvMllZQVZWS2g3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBbGVOYjhYdThhZGFpWit1dVkvOU9PWEpiCmZyeTcxTzdKTlRCd1hxYUNlVkplWlpkRXBjcXlsREJNVHVHNWRXdnpuang2NldSZU5uQnFhYWhiT2lZTG5ZYk8KUFdwNERRUURRRk40djcvdTVBZUZya0pFY2ZlZUFhTnRmYW5SSHNIWU9KNFdLOXlPU1BUbGl0Y09wUG9wTnZBQwpwd0JUbWl1YTdOemRTTWNEc2tTeDdRdVFtQ21GWGFuQm5jOHhKaUtUUVc0RnRnYWhidWdlbmR1bWtoSHQrRWo2CjhRTWY1dmM5am5URFVvaVl2VDVLR2NPTG4rQm1sSWxCeGlEMWZacEYyQzFRMHIwU3d1bU9VakwrWDdvUk50YysKWXJOTTZZVm9UWXJ4N1F1T1l2bkc3ZGdXeHlvaElOMi9ibTdiek9LV21NSWUrWkN1SDgzcTdDaHMrUWdlR3c9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nCLUSTER_IP_RANGE: 10.0.0.0/14\nCLUSTER_NAME: gke1\nCNI_HASH: 60bec898cffa83ee33023df0ea6001940f222e38d360e6829d05b821cff9921842418441abe8cbb9eada606edf50f0fe5730209311b8be5e035db022db4e3a5f\nCNI_SHA1: dcbeba8d6be7a49e399bda6b8b638d312eace876\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v0.8.5-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v0.8.5-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"true\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.3.240.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-06-25T14:35:31+00:00\"\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nFEATURE_GATES: DynamicKubeletConfig=false,RotateKubeletServerCertificate=true\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke1-47424322\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.3.240.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: 2d81bbf4be92bbb6fa787430dff367810a7653b29ec4a0b328fd03f085d65d2dd5f6db8d66308a227036e5a302d7ace428a421c2348edde07e01ef1f789d1c55\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: bq0FV20sBVb3n8atkvcB93Ki6N9CATMIIm51JMj2kGE=\nKUBELET_ARGS: --v=2 --cloud-provider=gce --experimental-check-node-capabilities-before-mount=true\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --bootstrap-kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig --node-status-max-images=25\n  --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBELET_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lRUHpnQzgzRnJkYmI3Ylk2L0RyZUtSakFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVFF6TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBU01SQXdEZ1lEVlFRREV3ZHJkV0psCmJHVjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXZvQyszMjVrTEdCdXZVb2EKcHE2L2c5VGwySmdiUXdkSE00QnB5RzZSVjJDUEZZQTAySmlES0RVcS82aDd0Zm5rZXZ2RXorTTZHTlJzMVQ5QQpKUi95S0hXSEZ4bTU1LzB4NHdCb3lERDlRek1sQWVkbWtLVHdQNXRDNzFCMzVrdkNVN2dOVmtLTUJCd0xpajVSCmYxMDI3NFhrVDR5VTZMdzBJMWZTREFyWmlYYWE5RnB1RmFxZ1JsMC9OdmVRcWsvVU95b1hlN2poUVdDaG1oT2oKcDRraGNrK2VpQzY2VXpwbjFCclBSamNlNDU1YlJkMTNQUjdIN3FNcXkzRTNzaThXNVRTRUswSVpUWlkxeGNLegpEVHBXNWxjVWRBN1RlSlpjNVBKZW9lUTZxemZDZ0dTVmFRcDVIUEVHd2pSS01RVkRXY1psVFdPMmdWYVN0ejlYCjJ1NThGd0lEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JUU1NWSFBEWXRhejJFZzRKRW8yWVlBVlZLaAo3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBTzZieno2NC9vRUFhTzRxUm1WM0hOMUZOZEd5YkE4SkZUQjg0CmtISUZ0cTYyVWJpb1oreStMci9XSVZXMTVkMzgrMmNlV2l1ZUl0L09qbkZtVFowUjZSWjRxT0dlUUZOM0NQeW0KQWpHT1hsTElvOFl6cEVFZXg3OGZITjFhSml3MGxxVk1FR0ZHZGJkTzlKMS80cjQzdmNBVmVSRkZHcm1vZXBQQwpMU294clJ4aVFoSi9NRlpjTnBqbFRmUzhpcG5reG5xaW1IOEdYTzZaMGlEa0VGQ2xjZVJicG9sc05qTDRtNnhxCmlmSEVHT1NRRk81OHRocFNxa29ZRXFRUkUva3BpN1Q3WnhFZFRzM3ZMdVVKK0ZhYTcxSGlFTjJHc2pEdE9WUWkKVjdDdW0vc21hSTMrZC9SaGtrUGpORWwwSU8wbmhUNUh3enVQTXB0OEFxbGZ2QUg2SUE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nKUBELET_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBdm9DKzMyNWtMR0J1dlVvYXBxNi9nOVRsMkpnYlF3ZEhNNEJweUc2UlYyQ1BGWUEwCjJKaURLRFVxLzZoN3RmbmtldnZFeitNNkdOUnMxVDlBSlIveUtIV0hGeG01NS8weDR3Qm95REQ5UXpNbEFlZG0Ka0tUd1A1dEM3MUIzNWt2Q1U3Z05Wa0tNQkJ3TGlqNVJmMTAyNzRYa1Q0eVU2THcwSTFmU0RBclppWGFhOUZwdQpGYXFnUmwwL052ZVFxay9VT3lvWGU3amhRV0NobWhPanA0a2hjaytlaUM2NlV6cG4xQnJQUmpjZTQ1NWJSZDEzClBSN0g3cU1xeTNFM3NpOFc1VFNFSzBJWlRaWTF4Y0t6RFRwVzVsY1VkQTdUZUpaYzVQSmVvZVE2cXpmQ2dHU1YKYVFwNUhQRUd3alJLTVFWRFdjWmxUV08yZ1ZhU3R6OVgydTU4RndJREFRQUJBb0lCQUJ0Y0dZMjBxTFc5alI5VQplRUFUZllxWDFnR1FmdXlCTEJjQ2QxbURsUTRyM2xZNUxvaDVCdS9odFp1TmZXUlBwU0tMUVkzckt0bmhaYXdPCnhIaWwwNUtVcG8wenlGWnEybkpVQ2JoNVhndW1XY2RNamtJY2lOWC9ITkxnQjEyazZIT1ErSGE0dDFhVHdlTXoKTzJNdVpsMi9mZ3NnRVV3eVUzbEwrMEo0S3h2L0ZENjVERWkyRTBzQzVMWjIvYnN6NUdiV3JFVVNHQTdSQk9URwoySlR1U205WDVYYk00UGNoSkVidElUOTRmdGx5QTlIdW9VdFRTQ0Z4Q29MWHRQNzh3RTlCVG5pNHRpV20vL0xaCm1sT2FLemNmR2dEbVpXbHowSi93b2E2UFNMVTBuUkcvWllBem5Dd1JzcWJXaDRWMTd0eVZ6UDRMNGJHblgwQUEKVnFpTTBsa0NnWUVBNkFIajdEQVB6aHdYQ3lUaXFlQkFqNkZFRWs0bzNyWmhrN1lFTTdyVEM0NENxczNRaWVrNwplcVVtMVB6MXJRei9DVjBUSFBQTTBMb3EwVDQvSUlvL2k0cGlEVDd2dkZ5aGVIOW52ZGJxL3hyK1YrNE9JaFlCCmtRS1VzZ0UydnpiYmZkbWh5MmZab3V4R3RJdnpkcEpXUFp2eUFjM2ZhR2FINFJLajNYb1h2YXNDZ1lFQTBqUVQKVlR3VG9zMG1xMzBteUp5cXNLMDNaUThsRnZaWW03TVhtdWQwMWZWYW9RYXJDamZnR1lZaGZuSGNWdlY4c3NPZAp2Y0NEMFNBdlBlNGtqeUxpT2lyaHdlaUNUSmdjOVZ5bTZ3WjdVK0VCaTAydW90UTZXY2prYURwRzJ3WjZ1UXp4CkIxSVlBelpNaFllYmowVkoyRWRxekVuWlRFYms1a0w4U1VkNkYwVUNnWUVBallsaHI1d2VlRUhndVBhMnBLWGYKSFFCbjA3Y0U3ZUZibzg0OXdBVXdiUE1rbzJqTjJPU0ZXYXZaQmNTUWFCTHVuNXE5WjBOQVp2RzczMHpYSEJYYQo4RmpxdW1Qend2akx0UVFjbU02OUxBWWV0aXZQU1hJZFlJYXZpZXg5cHFkanZlSC85MlFTZkhjaUoxRGRwUzlmCkYxVEVqZDgzZEt4Z0pxbkZkLzdjN3VNQ2dZRUF2c2VHMkhBN1BpSkdPNVRPRTN1bHE4NjZuUjArdzNWNGZHL3kKTjZSa3RTQUhUbWkzNmdGR2dzUHJPRkRzODN2QTNwcU9XejhVSkVTNnU5R2RHdEJGVlJmQWFIYTNjLzhISVdZagpGT0tBSW1Qd085ZVliYTZDK3lSS3NaSmE1c1VkczBCY3JoRkRPLzhYT29ZV21OVUJMYXU3OFlnQkVhcXlhNDVXClhjZml0cVVDZ1lFQXhwcG15VkpIcXhha0tuRWNURUgzc0hBMDBqbThTOC9raHRiUEVzdmdnNEkvaGsxWmtBSjkKbHFlUnZCQTdWdVZUTnd0Z0haZEhNcEtxNUFtKzBOZnB5cTN5MTltWEhCTHFad1hsYXIxVThMaDNtYXowWHlMago0WUhNcTdRLzV5anZ4NDF2azRtVU9jbVRUajRRMFExcE1JOWoyTzFSbUthY1d5VGxoK1pCb2ZNPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.78.155.57\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNODE_PROBLEM_DETECTOR_TOKEN: xDTwsYAE0JID1zZ92PFXELKbSKPkUFzuWb5vZbbRP8Y=\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: 547a4d625e71f6c905e8c552e4cacff0d8f60a5447ff98e3b6776e6500930ed888578151b09f878da9243b8a8f95e95aeb77abb9645c5776f01fdf49272bcaad\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.3.240.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1-b\n"
          },
          {
            "key": "cluster-uid",
            "value": "47424322166c49519dbdb364888d425f4ea5b7c7d3354c138a45e732e6e4c39a"
          },
          {
            "key": "cluster-location",
            "value": "europe-west1-b"
          }
        ],
        "kind": "compute#metadata"
      },
      "name": "gke-gke1-default-pool-564e261a-dgx7",
      "networkInterfaces": [
        {
          "accessConfigs": [
            {
              "kind": "compute#accessConfig",
              "name": "external-nat",
              "natIP": "34.78.105.195",
              "networkTier": "PREMIUM",
              "type": "ONE_TO_ONE_NAT"
            }
          ],
          "fingerprint": "vcUZotyCLFE=",
          "kind": "compute#networkInterface",
          "name": "nic0",
          "network": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/global/networks/default",
          "networkIP": "10.132.0.13",
          "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/regions/europe-west1/subnetworks/default"
        }
      ],
      "scheduling": {
        "automaticRestart": true,
        "onHostMaintenance": "MIGRATE",
        "preemptible": false
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/instances/gke-gke1-default-pool-564e261a-dgx7",
      "serviceAccounts": [
        {
          "email": "50670056743-compute@developer.gserviceaccount.com",
          "scopes": [
            "https://www.googleapis.com/auth/logging.write",
            "https://www.googleapis.com/auth/monitoring"
          ]
        }
      ],
      "shieldedInstanceConfig": {
        "enableIntegrityMonitoring": true,
        "enableSecureBoot": false,
        "enableVtpm": true
      },
      "shieldedInstanceIntegrityPolicy": {
        "updateAutoLearnPolicy": true
      },
      "startRestricted": false,
      "status": "RUNNING",
      "tags": {
        "fingerprint": "pCLl13iJLH4=",
        "items": [
          "gke-gke1-47424322-node"
        ]
      },
      "zone": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b"
    },
    {
      "canIpForward": true,
      "cpuPlatform": "Intel Haswell",
      "creationTimestamp": "2021-06-25T07:36:07.529-07:00",
      "deletionProtection": false,
      "disks": [
        {
          "autoDelete": true,
          "boot": true,
          "deviceName": "persistent-disk-0",
          "diskSizeGb": "100",
          "guestOsFeatures": [
            {
              "type": "SEV_CAPABLE"
            },
            {
              "type": "UEFI_COMPATIBLE"
            },
            {
              "type": "SECURE_BOOT"
            },
            {
              "type": "VIRTIO_SCSI_MULTIQUEUE"
            }
          ],
          "index": 0,
          "interface": "SCSI",
          "kind": "compute#attachedDisk",
          "licenses": [
            "https://www.googleapis.com/compute/v1/projects/cos-cloud-shielded/global/licenses/shielded-cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos",
            "https://www.googleapis.com/compute/v1/projects/cos-cloud/global/licenses/cos-pcid",
            "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/licenses/gke-node"
          ],
          "mode": "READ_WRITE",
          "shieldedInstanceInitialState": {
            "dbs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "dbxs": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              },
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "keks": [
              {
                "content": "REDACTED",
                "fileType": "X509"
              }
            ],
            "pk": {
              "content": "REDACTED",
              "fileType": "X509"
            }
          },
          "source": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/disks/gke-gke1-default-pool-564e261a-gzhv",
          "type": "PERSISTENT"
        }
      ],
      "fingerprint": "dqJu20-GqGQ=",
      "id": "660919917280253753",
      "kind": "compute#instance",
      "labelFingerprint": "mUgogP08_Iw=",
      "labels": {
        "gcp_doctor_test": "gke",
        "goog-gke-node": ""
      },
      "lastStartTimestamp": "2021-06-25T07:36:18.252-07:00",
      "machineType": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/machineTypes/e2-small",
      "metadata": {
        "fingerprint": "ZvGGNwyPIKs=",
        "items": [
          {
            "key": "instance-template",
            "value": "projects/50670056743/global/instanceTemplates/gke-gke1-default-pool-564e261a"
          },
          {
            "key": "created-by",
            "value": "projects/50670056743/zones/europe-west1-b/instanceGroupManagers/gke-gke1-default-pool-564e261a-grp"
          },
          {
            "key": "serial-port-logging-enable",
            "value": "true"
          },
          {
            "key": "kube-labels",
            "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
          },
          {
            "key": "google-compute-enable-pcid",
            "value": "true"
          },
          {
            "key": "enable-oslogin",
            "value": "false"
          },
          {
            "key": "kubelet-config",
            "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.3.240.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 512Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
          },
          {
            "key": "cluster-name",
            "value": "gke1"
          },
          {
            "key": "gci-update-strategy",
            "value": "update_disabled"
          },
          {
            "key": "gci-metrics-enabled",
            "value": "true"
          },
          {
            "key": "configure-sh",
            "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION=\"v0.8.7\"\nDEFAULT_CNI_HASH=\"8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede\"\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION=\"v0.8.7\"\nDEFAULT_NPD_HASH=\"853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea\"\nDEFAULT_CRICTL_VERSION=\"v1.18.0\"\nDEFAULT_CRICTL_HASH=\"9fe9f80f96542e90b47ae13726fd1cf6ed329117c64cefc1c0dda81b65a46551a6d273810efc689993eff41f2091536af9b536a2d0c6a51ec2e6480db26b6b8b\"\nDEFAULT_MOUNTER_TAR_SHA=\"7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516\"\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Use --retry-connrefused opt only if it's supported by curl.\nCURL_RETRY_CONNREFUSED=\"\"\nif curl --help | grep -q -- '--retry-connrefused'; then\n  CURL_RETRY_CONNREFUSED='--retry-connrefused'\nfi\n\nfunction set-broken-motd {\n  cat > /etc/motd <<EOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes to STDOUT.\n#\n# $1: URL path after /computeMetadata/v1/ (without heading slash).\nfunction get-metadata-value {\n    curl \\\n        --retry 5 \\\n        --retry-delay 3 \\\n        ${CURL_RETRY_CONNREFUSED} \\\n        --fail \\\n        --silent \\\n        -H 'Metadata-Flavor: Google' \\\n        \"http://metadata/computeMetadata/v1/${1}\"\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${kube_env_path}\" > \"${KUBE_HOME}/kube-env\")\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    $kube_env_hms_path\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    if curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${tmp_kubelet_config}\" \\\n        http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config; then\n      # only write to the final location if curl succeeds\n      mv \"${tmp_kubelet_config}\" \"${dest}\"\n    elif [[ \"${REQUIRE_METADATA_KUBELET_CONFIG_FILE:-false}\" == \"true\" ]]; then\n      echo \"== Failed to download required Kubelet config file from metadata server ==\"\n      exit 1\n    fi\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval $(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] < 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' < \"${tmp_kube_master_certs}\" > \"${KUBE_HOME}/kube-master-certs\")\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" -H \"Metadata-Flavor: Google\" -s | ${PYTHON} -c \\\n    'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl --fail --retry 5 --retry-delay 3 ${CURL_RETRY_CONNREFUSED} --silent --show-error \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" -H \"Metadata-Flavor: Google\" -s | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  local -r urls=( $* )\n  while true; do\n    for url in \"${urls[@]}\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 ${CURL_RETRY_CONNREFUSED} \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo $1 | tr \",\" \"\\n\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p $flexvolume_plugin_dir\n  mount --bind $flexvolume_plugin_dir $flexvolume_plugin_dir\n  mount -o remount,exec $flexvolume_plugin_dir\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"https://storage.googleapis.com/kubernetes-release\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_version=\"${CNI_VERSION}\"\n      local -r cni_hash=\"${CNI_HASH}\"\n  else\n      local -r cni_version=\"${DEFAULT_CNI_VERSION}\"\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-linux-amd64.tar.gz\"\n\n  # Create crictl config file.\n  cat > /etc/crictl.yaml <<EOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local -r manifests_tar_urls=( $(split-commas \"${KUBE_MANIFESTS_TAR_URL}\") )\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" -name \\*.yaml -or -name \\*.yaml.in | \\\n      xargs sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" -name \\*.manifest -or -name \\*.json | \\\n      xargs sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat > \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" <<EOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get >/dev/null 2>&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends ${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n    echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg \\\n    | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # containerd versions have slightly different url(s), so try both\n    ( curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-linux-amd64.tar.gz\" || \\\n      curl -fsSL \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.linux-amd64.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    curl -fsSL \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.amd64\" --output /usr/sbin/runc && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker >/dev/null 2>&1; then\n      install-docker\n      if ! command -v docker >/dev/null 2>&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ ! -z \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || ! -z \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr >/dev/null 2>&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd >/dev/null 2>&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc >/dev/null 2>&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local -r server_binary_tar_urls=( $(split-commas \"${SERVER_BINARY_TAR_URL}\") )\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO(awly): include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# retry-forever retries a command forever with a delay between retries.\n#\n# $1:     Delay between retries, in seconds.\n# $2..$N: Command to retry.\n#\n# e.g.: `retry-forever 30 do something` retries `do something` every 30s.\nfunction retry-forever {\n  local -r delay=$1\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $@ failed, retrying after ${delay}s ==\"\n    sleep ${delay}\n  done\n}\n\n######### Main Function ##########\necho \"Start to install kubernetes files\"\n# if install fails, message-of-the-day (motd) will warn at login shell\nset-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nif [[ \"$(python -V 2>&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} >/dev/null 2>&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version : \" $(${PYTHON} -V 2>&1)\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  install-hurl\n  install-inplace\nfi\n\n# download and source kube-env\nretry-forever 30 download-kube-env\nsource \"${KUBE_HOME}/kube-env\"\n\nretry-forever 10 download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 10 download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nensure-container-runtime\n\n# binaries and kube-system manifests\ninstall-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  retry-forever 30 inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\n"
          },
          {
            "key": "gci-ensure-gke-docker",
            "value": "true"
          },
          {
            "key": "disable-legacy-endpoints",
            "value": "true"
          },
          {
            "key": "user-data",
            "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      # Use --retry-connrefused opt only if it's supported by curl.\n      ExecStartPre=/bin/bash -c 'OPT=\"\"; if curl --help | grep -q -- \"--retry-connrefused\"; then OPT=\"--retry-connrefused\"; fi; /usr/bin/curl --fail --retry 5 --retry-delay 3 $OPT --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh'\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
          },
          {
            "key": "kube-env",
            "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=512Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURLakNDQWhLZ0F3SUJBZ0lRRUxqNjFNckxxNnE0L3JJY2FDeXA1VEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVE16TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBdk1TMHdLd1lEVlFRREV5UmxNMkl6Ck56aGxOUzFtTUdNMUxUUmlPVFF0WVRaaE9DMWpNbVZtT1dVNFlXVXpPR013Z2dFaU1BMEdDU3FHU0liM0RRRUIKQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUM4cUEwZlEvWW1tMUE2ZlBEbFFyM3MybWg3dmVleDcrM091ekxKc3VHRQpxQSsrb0lXb0w2ZGx2WEZIaWFmZUJkbGxNTCsrRngvc2diSU1GWkZCS1FBeXVoYWowaWdzdEN3dnBnSURwWmRICi8yVVZZbUNoZnhYY3ZFS01EOE84eXpENmgrd3RBODBFV2hYRHBVbU5yWHpXOE5YMWh6eDFGRUwzN3daYlIzUnYKaFNINUcrSldTNHQ1YjJBMi9UU1BYb2ovUWFrUFI4K01EV0VnejQ5cXdNRzFKQnMyeG1oYnp0TXFwSzhDR3RWWApZWjI4QXJmczJQanp2dUMrLzkzdjFHM1FETzdNTUU2NGFxZ3FwdGJjOGtnQzBXZXc1RWo4VWxkd1BFdXlqdVZ5CmRpSDd5OXJXR1Fvb3pJMEREZjNQMEpDVTduVkNuL3Y4czlPQjkrMnFuSFB2QWdNQkFBR2pRakJBTUE0R0ExVWQKRHdFQi93UUVBd0lDQkRBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUIwR0ExVWREZ1FXQkJUU1NWSFBEWXRhejJFZwo0SkVvMllZQVZWS2g3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBbGVOYjhYdThhZGFpWit1dVkvOU9PWEpiCmZyeTcxTzdKTlRCd1hxYUNlVkplWlpkRXBjcXlsREJNVHVHNWRXdnpuang2NldSZU5uQnFhYWhiT2lZTG5ZYk8KUFdwNERRUURRRk40djcvdTVBZUZya0pFY2ZlZUFhTnRmYW5SSHNIWU9KNFdLOXlPU1BUbGl0Y09wUG9wTnZBQwpwd0JUbWl1YTdOemRTTWNEc2tTeDdRdVFtQ21GWGFuQm5jOHhKaUtUUVc0RnRnYWhidWdlbmR1bWtoSHQrRWo2CjhRTWY1dmM5am5URFVvaVl2VDVLR2NPTG4rQm1sSWxCeGlEMWZacEYyQzFRMHIwU3d1bU9VakwrWDdvUk50YysKWXJOTTZZVm9UWXJ4N1F1T1l2bkc3ZGdXeHlvaElOMi9ibTdiek9LV21NSWUrWkN1SDgzcTdDaHMrUWdlR3c9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nCLUSTER_IP_RANGE: 10.0.0.0/14\nCLUSTER_NAME: gke1\nCNI_HASH: 60bec898cffa83ee33023df0ea6001940f222e38d360e6829d05b821cff9921842418441abe8cbb9eada606edf50f0fe5730209311b8be5e035db022db4e3a5f\nCNI_SHA1: dcbeba8d6be7a49e399bda6b8b638d312eace876\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v0.8.5-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v0.8.5-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"true\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.3.240.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-06-25T14:35:31+00:00\"\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nFEATURE_GATES: DynamicKubeletConfig=false,RotateKubeletServerCertificate=true\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke1-47424322\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.3.240.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: 2d81bbf4be92bbb6fa787430dff367810a7653b29ec4a0b328fd03f085d65d2dd5f6db8d66308a227036e5a302d7ace428a421c2348edde07e01ef1f789d1c55\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: bq0FV20sBVb3n8atkvcB93Ki6N9CATMIIm51JMj2kGE=\nKUBELET_ARGS: --v=2 --cloud-provider=gce --experimental-check-node-capabilities-before-mount=true\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --bootstrap-kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig --node-status-max-images=25\n  --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBELET_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lRUHpnQzgzRnJkYmI3Ylk2L0RyZUtSakFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSbE0ySXpOemhsTlMxbU1HTTFMVFJpT1RRdFlUWmhPQzFqTW1WbU9XVTRZV1V6T0dNdwpIaGNOTWpFd05qSTFNVFF6TlRNeVdoY05Nall3TmpJME1UUXpOVE15V2pBU01SQXdEZ1lEVlFRREV3ZHJkV0psCmJHVjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXZvQyszMjVrTEdCdXZVb2EKcHE2L2c5VGwySmdiUXdkSE00QnB5RzZSVjJDUEZZQTAySmlES0RVcS82aDd0Zm5rZXZ2RXorTTZHTlJzMVQ5QQpKUi95S0hXSEZ4bTU1LzB4NHdCb3lERDlRek1sQWVkbWtLVHdQNXRDNzFCMzVrdkNVN2dOVmtLTUJCd0xpajVSCmYxMDI3NFhrVDR5VTZMdzBJMWZTREFyWmlYYWE5RnB1RmFxZ1JsMC9OdmVRcWsvVU95b1hlN2poUVdDaG1oT2oKcDRraGNrK2VpQzY2VXpwbjFCclBSamNlNDU1YlJkMTNQUjdIN3FNcXkzRTNzaThXNVRTRUswSVpUWlkxeGNLegpEVHBXNWxjVWRBN1RlSlpjNVBKZW9lUTZxemZDZ0dTVmFRcDVIUEVHd2pSS01RVkRXY1psVFdPMmdWYVN0ejlYCjJ1NThGd0lEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JUU1NWSFBEWXRhejJFZzRKRW8yWVlBVlZLaAo3ekFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBTzZieno2NC9vRUFhTzRxUm1WM0hOMUZOZEd5YkE4SkZUQjg0CmtISUZ0cTYyVWJpb1oreStMci9XSVZXMTVkMzgrMmNlV2l1ZUl0L09qbkZtVFowUjZSWjRxT0dlUUZOM0NQeW0KQWpHT1hsTElvOFl6cEVFZXg3OGZITjFhSml3MGxxVk1FR0ZHZGJkTzlKMS80cjQzdmNBVmVSRkZHcm1vZXBQQwpMU294clJ4aVFoSi9NRlpjTnBqbFRmUzhpcG5reG5xaW1IOEdYTzZaMGlEa0VGQ2xjZVJicG9sc05qTDRtNnhxCmlmSEVHT1NRRk81OHRocFNxa29ZRXFRUkUva3BpN1Q3WnhFZFRzM3ZMdVVKK0ZhYTcxSGlFTjJHc2pEdE9WUWkKVjdDdW0vc21hSTMrZC9SaGtrUGpORWwwSU8wbmhUNUh3enVQTXB0OEFxbGZ2QUg2SUE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nKUBELET_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBdm9DKzMyNWtMR0J1dlVvYXBxNi9nOVRsMkpnYlF3ZEhNNEJweUc2UlYyQ1BGWUEwCjJKaURLRFVxLzZoN3RmbmtldnZFeitNNkdOUnMxVDlBSlIveUtIV0hGeG01NS8weDR3Qm95REQ5UXpNbEFlZG0Ka0tUd1A1dEM3MUIzNWt2Q1U3Z05Wa0tNQkJ3TGlqNVJmMTAyNzRYa1Q0eVU2THcwSTFmU0RBclppWGFhOUZwdQpGYXFnUmwwL052ZVFxay9VT3lvWGU3amhRV0NobWhPanA0a2hjaytlaUM2NlV6cG4xQnJQUmpjZTQ1NWJSZDEzClBSN0g3cU1xeTNFM3NpOFc1VFNFSzBJWlRaWTF4Y0t6RFRwVzVsY1VkQTdUZUpaYzVQSmVvZVE2cXpmQ2dHU1YKYVFwNUhQRUd3alJLTVFWRFdjWmxUV08yZ1ZhU3R6OVgydTU4RndJREFRQUJBb0lCQUJ0Y0dZMjBxTFc5alI5VQplRUFUZllxWDFnR1FmdXlCTEJjQ2QxbURsUTRyM2xZNUxvaDVCdS9odFp1TmZXUlBwU0tMUVkzckt0bmhaYXdPCnhIaWwwNUtVcG8wenlGWnEybkpVQ2JoNVhndW1XY2RNamtJY2lOWC9ITkxnQjEyazZIT1ErSGE0dDFhVHdlTXoKTzJNdVpsMi9mZ3NnRVV3eVUzbEwrMEo0S3h2L0ZENjVERWkyRTBzQzVMWjIvYnN6NUdiV3JFVVNHQTdSQk9URwoySlR1U205WDVYYk00UGNoSkVidElUOTRmdGx5QTlIdW9VdFRTQ0Z4Q29MWHRQNzh3RTlCVG5pNHRpV20vL0xaCm1sT2FLemNmR2dEbVpXbHowSi93b2E2UFNMVTBuUkcvWllBem5Dd1JzcWJXaDRWMTd0eVZ6UDRMNGJHblgwQUEKVnFpTTBsa0NnWUVBNkFIajdEQVB6aHdYQ3lUaXFlQkFqNkZFRWs0bzNyWmhrN1lFTTdyVEM0NENxczNRaWVrNwplcVVtMVB6MXJRei9DVjBUSFBQTTBMb3EwVDQvSUlvL2k0cGlEVDd2dkZ5aGVIOW52ZGJxL3hyK1YrNE9JaFlCCmtRS1VzZ0UydnpiYmZkbWh5MmZab3V4R3RJdnpkcEpXUFp2eUFjM2ZhR2FINFJLajNYb1h2YXNDZ1lFQTBqUVQKVlR3VG9zMG1xMzBteUp5cXNLMDNaUThsRnZaWW03TVhtdWQwMWZWYW9RYXJDamZnR1lZaGZuSGNWdlY4c3NPZAp2Y0NEMFNBdlBlNGtqeUxpT2lyaHdlaUNUSmdjOVZ5bTZ3WjdVK0VCaTAydW90UTZXY2prYURwRzJ3WjZ1UXp4CkIxSVlBelpNaFllYmowVkoyRWRxekVuWlRFYms1a0w4U1VkNkYwVUNnWUVBallsaHI1d2VlRUhndVBhMnBLWGYKSFFCbjA3Y0U3ZUZibzg0OXdBVXdiUE1rbzJqTjJPU0ZXYXZaQmNTUWFCTHVuNXE5WjBOQVp2RzczMHpYSEJYYQo4RmpxdW1Qend2akx0UVFjbU02OUxBWWV0aXZQU1hJZFlJYXZpZXg5cHFkanZlSC85MlFTZkhjaUoxRGRwUzlmCkYxVEVqZDgzZEt4Z0pxbkZkLzdjN3VNQ2dZRUF2c2VHMkhBN1BpSkdPNVRPRTN1bHE4NjZuUjArdzNWNGZHL3kKTjZSa3RTQUhUbWkzNmdGR2dzUHJPRkRzODN2QTNwcU9XejhVSkVTNnU5R2RHdEJGVlJmQWFIYTNjLzhISVdZagpGT0tBSW1Qd085ZVliYTZDK3lSS3NaSmE1c1VkczBCY3JoRkRPLzhYT29ZV21OVUJMYXU3OFlnQkVhcXlhNDVXClhjZml0cVVDZ1lFQXhwcG15VkpIcXhha0tuRWNURUgzc0hBMDBqbThTOC9raHRiUEVzdmdnNEkvaGsxWmtBSjkKbHFlUnZCQTdWdVZUTnd0Z0haZEhNcEtxNUFtKzBOZnB5cTN5MTltWEhCTHFad1hsYXIxVThMaDNtYXowWHlMago0WUhNcTdRLzV5anZ4NDF2azRtVU9jbVRUajRRMFExcE1JOWoyTzFSbUthY1d5VGxoK1pCb2ZNPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.78.155.57\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNODE_PROBLEM_DETECTOR_TOKEN: xDTwsYAE0JID1zZ92PFXELKbSKPkUFzuWb5vZbbRP8Y=\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: 547a4d625e71f6c905e8c552e4cacff0d8f60a5447ff98e3b6776e6500930ed888578151b09f878da9243b8a8f95e95aeb77abb9645c5776f01fdf49272bcaad\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.19.10-gke.1600/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.3.240.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1-b\n"
          },
          {
            "key": "cluster-uid",
            "value": "47424322166c49519dbdb364888d425f4ea5b7c7d3354c138a45e732e6e4c39a"
          },
          {
            "key": "cluster-location",
            "value": "europe-west1-b"
          }
        ],
        "kind": "compute#metadata"
      },
      "name": "gke-gke1-default-pool-564e261a-gzhv",
      "networkInterfaces": [
        {
          "accessConfigs": [
            {
              "kind": "compute#accessConfig",
              "name": "external-nat",
              "natIP": "34.79.125.138",
              "networkTier": "PREMIUM",
              "type": "ONE_TO_ONE_NAT"
            }
          ],
          "fingerprint": "Vh-YKFGiQN4=",
          "kind": "compute#networkInterface",
          "name": "nic0",
          "network": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/global/networks/default",
          "networkIP": "10.132.0.14",
          "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/regions/europe-west1/subnetworks/default"
        }
      ],
      "scheduling": {
        "automaticRestart": true,
        "onHostMaintenance": "MIGRATE",
        "preemptible": false
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/instances/gke-gke1-default-pool-564e261a-gzhv",
      "serviceAccounts": [
        {
          "email": "50670056743-compute@developer.gserviceaccount.com",
          "scopes": [
            "https://www.googleapis.com/auth/logging.write",
            "https://www.googleapis.com/auth/monitoring"
          ]
        }
      ],
      "shieldedInstanceConfig": {
        "enableIntegrityMonitoring": true,
        "enableSecureBoot": false,
        "enableVtpm": true
      },
      "shieldedInstanceIntegrityPolicy": {
        "updateAutoLearnPolicy": true
      },
      "startRestricted": false,
      "status": "RUNNING",
      "tags": {
        "fingerprint": "pCLl13iJLH4=",
        "items": [
          "gke-gke1-47424322-node"
        ]
      },
      "zone": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b"
    }
  ],
  "kind": "compute#instanceList",
  "nextPageToken": "ClgI_O3M0eL48QI6TQoCGAMKAyC1EAoCGAIKByCn6q7hvAEKAhgHCiUqI2drZS1na2UxLWRlZmF1bHQtcG9vbC01NjRlMjYxYS1nemh2Cgogua7h85vlg5YJ",
  "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpd-gce1-4exv/zones/europe-west1-b/instances"
}
