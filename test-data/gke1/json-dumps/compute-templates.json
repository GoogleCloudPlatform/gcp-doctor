{
  "id": "projects/gcpdiag-gke1-aaaa/global/instanceTemplates",
  "items": [
    {
      "id": "3679790333010400777",
      "creationTimestamp": "2021-12-06T02:41:42.870-08:00",
      "name": "gke-gke1-default-pool-d6415eb8",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke1-170a398a-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west4/subnetworks/gke1-subnet",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke1-secondary-range-pod"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "foo": "bar",
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "-y71zCeDmgc=",
          "items": [
            {
              "key": "cluster-location",
              "value": "europe-west4-a"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2,node.kubernetes.io/masq-agent-ds-ready=true;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMVENDQXBXZ0F3SUJBZ0lSQUpxRS83N0ExUVlJOG5Uc2hsNzhSVFF3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa016STVabVF4TXpBdE1XRXdOUzAwTURobExXSmtPR1F0TnpBNVlUZ3lORGhsWlRFdwpNQ0FYRFRJeE1USXdOakE1TkRFek1Gb1lEekl3TlRFeE1USTVNVEEwTVRNd1dqQXZNUzB3S3dZRFZRUURFeVF6Ck1qbG1aREV6TUMweFlUQTFMVFF3T0dVdFltUTRaQzAzTURsaE9ESTBPR1ZsTVRBd2dnR2lNQTBHQ1NxR1NJYjMKRFFFQkFRVUFBNElCandBd2dnR0tBb0lCZ1FEcWdHcXRtbVFsTFZmZG5yU3FBKzNwbWJ1MkdWL2tnN0MwMmRmKwowaGJMM2hLMnNvcjlzOUtYOThDY2FpSzJ3aFUrYzYwNzNpY0xENEhwV3A4QzVDVjJJZTZQVFl2Q3pESnBQSEVRCnhFYnhiMHJQTENCWGhoNTNTMXgrUk1aLzhiTWVraGRUMDk0OWtaRDBVeTY0bXpCVWxVUnEwYzdGU2krNnUzd2oKSVRzOVVTQlBGbE0zZ3pHellEaktsRG90TFowYW1pek1FWWpSSHZzT01uTGF1ZmxUU1p0ZFgwM2lQVThnVTlNLwpaS2s4Q1kwOEVqQk4zKzBHNDhVOHViMElrenRGV1cvUlpiOEI1S3pJTHBZR0VGcHJQQW1BVEhqTllldllGcEs2CmpLSVFoWGdWdEJIa0hGMk82VHV0alRjWHFzNnMxanYzbk0wT1M1aG1BKy9WNDI2Y3RaMjk3ZGxqTlZTVHNkYnIKT3liRU1WSVhEcWpodU00N1lKWkVtcmFDYmc5K0wxNFBXZ3BiN0tNWUhPMytnZDBDWUozZ2JPQ2pNOHRzNXU1TwphNy9yTnZRbkthRGNJdnVNR0lpVTh3L3JYN2ZhYXNjaytwYmF6bTY2bmlFZDIvcU5RdGRZR0VTYW05aVNsQUMyCjg4V3hySVFjVFBmSVkxV09ORmpXUmpJT2Yyc0NBd0VBQWFOQ01FQXdEZ1lEVlIwUEFRSC9CQVFEQWdJRU1BOEcKQTFVZEV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGSHpvd3NjbWw1UDR0Vmt2Vllvb3VwMXRwMzBHTUEwRwpDU3FHU0liM0RRRUJDd1VBQTRJQmdRQ3duRkhWeExyV0ZFaHdzSnk0bFRHVHhDRHREa2tkOENrRGVoejR4UmxwClFaY3haaUVCVjNPRjJvMVRNNEZ0dXBHRks0WGg5WkR0VWxqM1EzTjRrdTRSYXNQbDdMeGRlT3lVTHdYR01Za2wKM0NZOW4xZlFJS0hWVHlsa25HUy82UmxzbVZHdjJjRU40U2tXNVFNbm00M3piTVlHbzdzcnh0V2U3c1YzcVJaOApmOVAvVDRSR3BEbHlReWxTRUhycUZsaWxTbVZIL0prUzBNVFNoak0vbGxEUGc0cWdPdkpKM3RFbXp1MUtpSC85Clp3enV1dE9ZckhFZXU1MUhMa01uaE85YnhsQ3hXRzRIRWljZklpbEwrQ1FKdUd1d0I2RFczWDB0RVVMUXVoY2sKbXpKNHNsK1czZm9NNGo3LzY4K2IzVVF3OC8xMzVEWVpSVnB6V1lCNjRaUFVwQWVIUTR3b3lUT3JsWE5JNzJCTApDdUkvbFVLcUlBaWR4TUR2ZUNuQWllakJqYjFhVk5CbnBxemgzWmF4cVRNZVBpVitVdFg1TWd0NWdmQ1hRaVNXCm9hbk1QYi9EMmNETkpCekxDSncvQkpPaWxBTW9hNm91SXJaVFlpQ2kxMVFsUlZuYkIxWDZ3RU15ZG05a0dCeksKdXhSRm9NbG1uMy81YXlNQWFLYXpaeHM9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 192.168.1.0/24\nCLUSTER_NAME: gke1\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 192.168.2.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:41:27+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke1-170a398a\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 192.168.2.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: iksO6yN9XLzgWPr_uk7vm8_U759vcdUs27WoqSDLNdg=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.90.133.45\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 192.168.2.0/24\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxakNDQWhLZ0F3SUJBZ0lQZkFFcW05bWNiQUZIZkxYWTA1a2JNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1DOHgKTFRBckJnTlZCQU1USkRNeU9XWmtNVE13TFRGaE1EVXROREE0WlMxaVpEaGtMVGN3T1dFNE1qUTRaV1V4TURBZQpGdzB5TVRFeU1EWXhNRFF4TXpGYUZ3MHlOakV5TURVeE1EUXhNekZhTUJ3eEdqQVlCZ05WQkFNVEVXdDFZbVZzClpYUXRZbTl2ZEhOMGNtRndNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXVBVW8KN2R6VDBCWlgxcVNpVVF6Z0FYTVlreTdHUWNzdGtEUm1ZRWNwZmNqU3JQdWpvRXNjeEpzNUJkMmZVZjI4cjdJMApZUUpNUktkb21SVnFXWDdnZGtodlpoKzFERGtlNFZCWGJQUkozUHhYRGY0TG4zQzdhTXV3RmpoemZzZ1JOaG9ZCjBRcXU4enl2QkRXWGdyVlRyUnc4RWNkaWU2OHhyQ0FpTml2VWRNM2syTko2d0h0bVlpdGNlazRXeWR1SCtKcmcKMHB0SWFKTGtIQlY1d0M2WVFLVXI2b0diNEg2YWlWNTcyZWVNR0Z0MXlZRzhqZk5HSXM2N3RwZE02ZkJvcjlnTApONVlnQ2liYmExWDZncTl1WGFKaVBlZkxKRnkwN2VRVFczS0VBSE9Dd1FSUnNTMzh6Tjd6NkdWTEttOXVIb08xCnJNQTRTekdYcEVYdmVPYjNpd0lEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3cKQ2dZSUt3WUJCUVVIQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JSODZNTEhKcGVUK0xWWgpMMVdLS0xxZGJhZDlCakFOQmdrcWhraUc5dzBCQVFzRkFBT0NBWUVBRjVBcnZpSVU3T2t5cWdnL1NXMjhpU1BXCkYxM0tGQmlXTmpqUk01ZHd6QXpLU2VSOGJ0RzNsZGNaMWVtVmtCUWRweFpheXFFWmxMYit1anFVaStXVXZabFYKbGxtOE5qWk50TlB2UkhzVHdqRHdMV1NRUWVEOXdJUFdiNWdvRmxtUnZmQTBUemVRZFlPaXdSdjlUakk5U2VOYgoxZ1RaUVpRekVxUzBjUzk2dTlXY21sN0V2ZHloWmNaakdMbC9PLzQycVdKOUY0cHd2ZUt0M3lDbG1JRHZsY01TCjFIY3pTdlVKYi9DN0ZEUHM4dFk3RlVlNGlpR2t0U1pqdkgwQnVpaXkwVUVNYjhNckZSbnV4WjRPUUhKbHRKZEUKOWVScXplUEJBNW4xSFNUYTdrUW5pSUFUelg3WEVJZ3FxclFBTGxwbi9HQVliSG1RYlVxR3FINm5LWnZPcjZVSApScWF5VFdLK0VneFo0Nkd6MktOYWtUWkQ1ZGRIa1ZUMTNzcnZmdlc3TXYvN3dqZjNWQU85Yk5LUXhLNnhPdzlUCm5BZ1YxZ3RpdXRiMGZkR1AvNnBBR1llVGoremNjb213c2pRbkFSSGpscXo3SHZsV1Rhd3ljek80S1NkNktNOGoKSndTU3B3ditoNkFFSm9HOExyR2RNNmczSThZYXpXcmQxNFFaVWpvdgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb2dJQkFBS0NBUUVBdUFVbzdkelQwQlpYMXFTaVVRemdBWE1Za3k3R1Fjc3RrRFJtWUVjcGZjalNyUHVqCm9Fc2N4SnM1QmQyZlVmMjhyN0kwWVFKTVJLZG9tUlZxV1g3Z2RraHZaaCsxRERrZTRWQlhiUFJKM1B4WERmNEwKbjNDN2FNdXdGamh6ZnNnUk5ob1kwUXF1OHp5dkJEV1hnclZUclJ3OEVjZGllNjh4ckNBaU5pdlVkTTNrMk5KNgp3SHRtWWl0Y2VrNFd5ZHVIK0pyZzBwdElhSkxrSEJWNXdDNllRS1VyNm9HYjRINmFpVjU3MmVlTUdGdDF5WUc4CmpmTkdJczY3dHBkTTZmQm9yOWdMTjVZZ0NpYmJhMVg2Z3E5dVhhSmlQZWZMSkZ5MDdlUVRXM0tFQUhPQ3dRUlIKc1MzOHpON3o2R1ZMS205dUhvTzFyTUE0U3pHWHBFWHZlT2IzaXdJREFRQUJBb0lCQUJwVkVyQkc0MEJwa2hReQo1czgyU20rcXFwK1ZGK1dlVDF6TlFzRVFMYzNFQ1BHYjZLUXRXMlorMThBUklKVTQrK0VnWFFKc3M4RTNPMjU4CmRBVnVkR3c0blVnOXpVaDhmQUM5NEdURTZEVHBId1B2a0hZMlNYc0xlcDBUWXVPSGVYOEdhUHF3enF3YnlPZVAKUzZqMmpZeTk5NUtMdDNuL2JkbzFsdSt0Z2U5Y3NLVlZIODdLSk5ONHIwZlNQeEZCb2FQZ2hXdmVmODRNR1VKagp5NlM5SmtyYkR0bkk0dWZZN0lmYm02VlZwc2VxSVlEWlpHZjZNekppUndxVXlMK0FyTUhxVnVzeDNQVVUxdzFiCjdFR2Vya2ZQQjg5bEpqTDZaSS9QQkZoOE1PSHhFTnJxY2xGMnd1YzRvU0ZyeEtnVkU3dndUVTlNdWZZcjRFY2UKLzZkMlVxRUNnWUVBOFVxVFVKNEdCVWQyMS9WRE1uNkdQMDVpZC9Hcm03enBSUmpFYTljc0FvVUFPRmNHR0hVdQpyNk02bUZKS0l1YkRscXdXUGxsR1JPOVIvTnBLMHF2azIwYUd3Ui9qRXVud1hZMks0N0lPZzhKR3NxVXVDMjBiCmF6eDRPdXd3a3pNa2paUEhMT013d1AyNEtQeWdzZlBDR1VWR3Z4VzJzaFo2MTdFZmNnejRqK2tDZ1lFQXd6eloKdjdySVJDM1R1ZGlXVGl0U0pieXJXbVpzM3lna3p1OU9STituRGRmL1VNMkdhZWNqNXlwRnBJQVpqd3dkbVhwNwpQS2RCaHluV2trbHd6VlJXQTVobllNTTM0UHlST2ZHVndtd1hqbE9WV1h5L0RrYWJqQ0YycHJZYnZhUmM2WnBYCkp2MnRMNktCUDVkSW0vS01lRURxS1czNjZhZXllcVB6bGQ0emQxTUNnWUJmK2QzbTd6Uk4zVU0wVzJaREszaVMKcmNjVkZwZS85c0NDcjN0UnVlRFRqN3VxclZMTFg3RVdROE1HMjVTSmxXaXZBZnhIQ0pPZXorSzR4TXVHU01GYgpSdzVLdXpoRFNiSkdSQXErenhCZThHUFdvMFZSWGpETjB0dXY5RXJPQWtYRDJzZ2Ezck9CMEduMFE2aFhvREhRCmczSEVpQXFIZzlHUkFlOFVHbnkwSVFLQmdEMWVTek94Q25JajFZRjlTd0dYTEdNZ1F0eFBoYmsvYlJKK3RpT0EKQ1lxWWNuQjdxZHh3QXlFT2NJV2NubXdRYXQxcldvRmVNWUxDNitkZm5rMXNUUDBrVXBwZndwaTl5d2hqbjZkVgpRckpDSTVmVlZsaXVhUVpMSG5pWWxXK3UwbVc3VmRtenMxUmR5REtzNHUzaDk3VjA4aVhEcERMOXUyUkJWTGV1CitJNXhBb0dBYkVuOVRCWVJ5bURGQ2tWUUtEUmF0ZWZGQWUrd3IxMFRnRHE0K210bnJPaG1HOEdaenlRU2IrMC8KS3lXUUt4eWdRckRyMUdDT0Z5MVBXaW9NMThxUXR4RzFXOWpGbjFWYnBSckNiMi9vSUoyS2NXaXZ1a0swWEl1YQpCWHFadlVueEJJZXFVaWYza1o1b2dHL1R1ZkdXUjlVcVlGUnlmR1lTa0J2VkYvdlVMNkU9Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west4-a\n"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "cluster-name",
              "value": "gke1"
            },
            {
              "key": "cluster-uid",
              "value": "170a398a0faf45f4b13f456dd5f7dc68802dc5a376d64ffdba53160991e5bb5e"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2,node.kubernetes.io/masq-agent-ds-ready=true"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 192.168.2.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.90.133.45\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "default",
            "scopes": [
              "https://www.googleapis.com/auth/devstorage.read_only",
              "https://www.googleapis.com/auth/logging.write",
              "https://www.googleapis.com/auth/monitoring",
              "https://www.googleapis.com/auth/service.management.readonly",
              "https://www.googleapis.com/auth/servicecontrol",
              "https://www.googleapis.com/auth/trace.append"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "foo": "bar",
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke1-default-pool-d6415eb8",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "3355145656460137996",
      "creationTimestamp": "2021-12-06T02:41:39.563-08:00",
      "name": "gke-gke2-default-pool-2aaf97f7",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke2-709dc5cc-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke2-pods-709dc5cc"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "aaySSHS9M-0=",
          "items": [
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.116.0.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "cluster-name",
              "value": "gke2"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRWDNvck1HaUU0UnM4Y1hLTUhmd3dUREFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpJQmNOTWpFeE1qQTJNRGswTURVM1doZ1BNakExTVRFeE1qa3hNRFF3TlRkYU1DOHhMVEFyQmdOVkJBTVRKRFJsClpUUTVZbUkwTFdVM09HSXROR1ZtTnkxaU5EQXlMVFkzTmpKaU56ZGhNbVkzTnpDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQU9GdDdXUm1rSlpaMUdvMTd0RzZqNiszRzQrdEEzTlQ1Zm9hVC9TLwpCRFFMNHRyN3E0WnJxYjJlLzFKbVBBemhoY1pmdE1mdTZvdEdZaGg0ZVdyU0lBZ1BiekpSV0pjK1F6Ti9ZODR5CndZL1JCN1g0OGo4YzNvblpMZWN6dzgzTXJKNGgvNFBsTUhEdGx1d2tjaDZCWVJVY04rOW8xZGlycDEySVJpWkIKL25MY1Nib3NTcUZrM0szRzlreE9TTWhEc0RiaVVDR0pMZTk0UjRkK0U3Vm83MGFJMHlrczBFMzNpeDU5Nmd2RwpNYlhxVFNWR29Wck5LNzJ3VHl0cmtSbURsWE11TWhMMmRkTzBXU2RjT2lNQW54K00vVkZjWHNGaWxOUFpLckdhCkVESGlDSGNZUis4TDlvMWhsME93dXBEY2k5akprSmFTWFF6b2dXVnVGUGFqclVzMDFFWWZnOTBpWDZGVS9wQkEKLytmaEhUbEpORkhkb0RXQzFMVyt5Mld3WW12WnRESjUwSlpVYzUwRStpMWRyNVpRN0I0U21zMXd4eFdaWFVpUQp1d1N6Q0VrUWRMZFV3Ti9jUHRYN2hvQndCdmsvTGNvaHN4cTI5RFBNemNkOVUvMUdnbHR4bzRhOG9YaXQ3cmFMCno5WENtcDVGMGF6THNCeVZKOUY0SjE5QTd3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVUxMUh5cWZvalFMWVcwdEtHZEkydElEcTVVR0F3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFGbERoQm1RUXZTSTBvM2drZmhzRVplbEVoUmpGeE8xSCtaUGh1MW5rWGdFClp1MlBXY2pLR0FzRFJOOVRqZ2lqYVo4OUFCd3VMeUUyenY5YmE0U25SYk5ac0NMSFYyR1VGeFNla1BmaVZNZk0KNHlvcWpwS1VTMjNQM05kN1dYQTQ1M1B3QkFIeks4NW1ZRXFreFdtR3Q0WDJLNWluaUM5VGh0UC9mN2xDMnlWeAp3blViUExZUGdrK0pDK1E0bE96bWVIUnpOTnJ0eC9ybCtVYWptSW9iVkpjUHVTZElkWjZiTHdJWWhYRUtCVEVJCnJGbmowWll1SmN2SjdWckYyT2pjZ2REUjZSRkhrcy9EV0g3T1I2dklmbjAwMkxERmt0ZC9WUmc3THV5ekM1NkEKRWxrdGYyNVI5bFRuTmJmOG1RNGt0cWFlQjVLRDJvRnRYNHVleVRORzJXRzc0WTRYaDlkZkZ2Tkgzc0NiRXZqQwpGRTRuUjZWTTRWRTRvNDMrVmJJcERDTDZaYVFick1tTmtrS1dqNzlvZ0ZTeENxUm1VMDZYNUFpY2NXbU5iendtClNuZklsYlF2aXhuOVo1dmI5VTk0eWQwSk1zWnlYcFBtaEdReVZxSnVadG9OSVkraXdNZW1FMFlMbE9TQVFteGYKNndYNC9MeTRNVWhuaFg4UFJwamNjZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.112.0.0/14\nCLUSTER_NAME: gke2\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.116.0.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke2-709dc5cc\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.116.0.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: R_zASgm2sOPE7kJO9HzSig3YNJ_TLBCh73Qd7aF_wDk=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.79.139.44\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.116.0.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRUkxZSm1BRUtGSkdaK3prZVZVV1hJVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKOEgKY25IREkwYm9KcU9IeUZhUGNrSHE5RmF2Uk05UWhUejZtYjB0U1Q5YUJENkphNTk4YUFiUm1lVzdUcHhETFZwdgowL0JTdWdsSEY0NCt6K1VXZUtVbnVCZTVOdm44ZHIweStEdzR3MHVpdGcxMkNEK1lWYmFyZHhJa1pzcnc0UWVaCm9lNlA3NUxQaTFna1RnNVc3alZOTmVxQTZYYTFuQ2swWm5HTFNYSkh4MERDZXAwa21pOGt4RGprKzIxdTdCMk4KV05rZll3QWI3elRsOUFGUTlBV3QrbS9OWElESEVUMTRFcUh5dWVYVFJhUVdWYTIvY0hUaXp3a1QrMWR5ajhuSApwRjdsZEl2aGlxVnFwdlVoR3llNkJRVzcxdWZVaGx5QWN4dW1QK1RuZ0xabTVSSytWMFJFQXhvSW5BOTNGdVpKCkJQNXpLV3l2SWhIOXNDOWxiblVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVTExSHlxZm9qUUxZVwowdEtHZEkydElEcTVVR0F3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUE5RGdrNnhaUXA0WU1IZU9YT0lMQ0xiCjJSL1lZeXFFUnpTS1A2WmduekMzRGpUWTlCV3ZyQ1BXdU9maTZpRkpyUlE4T0JmV2wwZ01EQkMwQmF4djJQRmIKTzZGenByNFIyemxCelVSVTdLWUpucmFuTHhMM05oU1ZTTWRVNnQ4SWNtWmcxSVc4Mm5OVm9OU3lkOHIzZkRLYgpqcCt0bmNlb28veVBJNGhPc1J1aEthTjlHSThPM0JzOUQzODVZNW05RzBOeXJ4c2tjeWJqUUVOSURBdlYyb1NYClFpd01VUXpudFlodWxKc2ZyR1AxdVRRb0pQZkR2OWlnbE1vL0pRem5ESkg1aHdTT1lMZlJTMGRiWUlxUWZOL2MKUjZ3d2JWb004b0FsS1BsZndaRFo4dVJFR3RFQUlHdDdEMFJPeVpiODdMWnNObGNuN1NJZ3VxamNpbnB6b3BMWgowNC83TnoyWEZZWTV3VmVVb2FzOVdnN3JTYU01ZU11QXNBd2NYWU1UOTFqVXEvZ1hxZWlxcUVjSzZPYkZPWUxvCnRIN1JPRnh2V0RUNFVpMDZLZXRDY3hSWnp4Z0E2OUlsbW9xVVVrbUpDRjlkemc5V3I5Z1RMcTliT3BwUUpVM3QKVEg0Vkl2RHozODVrYnYrVW1Rb3JURVhzOWR5UHhKMXh3TmlVT293ZTFBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBbndkeWNjTWpSdWdtbzRmSVZvOXlRZXIwVnE5RXoxQ0ZQUHFadlMxSlAxb0VQb2xyCm4zeG9CdEdaNWJ0T25FTXRXbS9UOEZLNkNVY1hqajdQNVJaNHBTZTRGN2syK2Z4MnZUTDRQRGpEUzZLMkRYWUkKUDVoVnRxdDNFaVJteXZEaEI1bWg3by92a3MrTFdDUk9EbGJ1TlUwMTZvRHBkcldjS1RSbWNZdEpja2ZIUU1KNgpuU1NhTHlURU9PVDdiVzdzSFkxWTJSOWpBQnZ2Tk9YMEFWRDBCYTM2YjgxY2dNY1JQWGdTb2ZLNTVkTkZwQlpWCnJiOXdkT0xQQ1JQN1YzS1B5Y2VrWHVWMGkrR0twV3FtOVNFYko3b0ZCYnZXNTlTR1hJQnpHNlkvNU9lQXRtYmwKRXI1WFJFUURHZ2ljRDNjVzVra0Uvbk1wYks4aUVmMndMMlZ1ZFFJREFRQUJBb0lCQUJkR0VIeHdOYzg0aGdFYwpTOWhKTll4S25iZzYvZHZHV2IySEltMVNmWndKS1VKYXU3YXpUd2tpYno2MUZ5ZmMxL3dhamg2bmlNVDNVODMwClNOb3EyL3kxcjZZL0s3blJ0akh4emUwSVZLS1MzVWhpakFuOG1oeTZBdHJUbTN5YlhKK1BYeWpLQldLTHY4V20KU0lzbU0wWDNOd3NMRXovVmk5Vm03eEF5ZFkwRkU2YktmbVdYdzdxTGNOVzVzMTRlcURSY1pONVRRQllxbXVFegp2eHp2dE5EejlveTNjT1dCci9QOGRaY1RiWGdOMC8rMEs4VEUyaGdCMkV3YnhPT2x6ZDFqM3ZtbUp2K2xtQzhVCmUzenFCcE5FbmN4SjZrQzB6Sml1VFE0TitBWkU2QjlRR0xKOEt2MDVJVGlMd2p4U1hMazZaaWVlTFIzUjI3b2cKZCtDQ2U5RUNnWUVBekNlRlVKQ1hLcVhMSEVtVml1WGZBK1d2Ni9QNHN0Mno2ZkNERnBXTGprT3NueGNPblFObwoweVV3eFZBV09BY3Y0STUybmhULzVyTmhLRlBZbUVWMVI0QkQvMHhsUzliNTJpYmgxZ2d6YjI2bW9rVnVOamtUCnpMbFlySXF3WDIyZzEweU5RcTBsZkR1TzhFZk1vczBwSVZiS3NCV1p3clFGeHRsWUVEUlFKcVVDZ1lFQXgybysKQWJXL3duaDArKzhBbmxzcE45dGtNRkliZGN2NXpJT053Vy93a0QwdFFidGE4TkRxVm9hYnE1UDg0ZDFFNHliZwpCZSswU091bzZ6dE1rQTJ4a3JKTCtraGhNWXBCeTh0a3RVTlhFdVZVdVRuU1YwSlczRTg0dTBLQ0lSUVdZeWdyCnpXVFZWTmRkcDhRQWVOQW9hc2p6QWdBT0RMWjEwSlQ4WmJIbWI1RUNnWUE3VHZQa3pzeUxvRFNjV0Nnd2ZNMUkKRlk4QTdoUis2ZmRkYS9pNU0rS2lCcmo4VXJkMUY4dDVJNkhDZ0p5ajFEcXRjdFcwNFFiaW41UUhJaXlYTi81MQpNaWNPNE1QQXY0aEFQdkYydTFVdDl5aERsZ1lKakpWYThURjRscVhjWXozSnJqeVBkVHVobHEvVTBCYjc2THdkCktsaWh4UFN4WXBrWEJvY1YxZ3krM1FLQmdDaHJuSTMwTFI1YUZEeE13YTlYZ3c5VFpRZDJYU0tQYWQ3T2U1bE4KKzFFQlZYOFJYdW1aTHliQ3VpTVpLQlVRS0xweVVzNWhQQVhiM3Exdm82RS9aVkw2MlBPdVlDVU9oUyt0MW9mMwpVbHIrS1NJeVdqUmR1Z1dGK1ZYYnNVekxLWTZId2Zrc0N5SGJWWngvMmlpaTZNNWNWUVYreFZwR1ViTXB2ODlOCk5BeEJBb0dCQUoyQ1owV0kvM21YaVZnc3B4emE1WnRjb3Z6cUEyVkdVRHh1Q2V4bEhYZWg1Z2dtS21xWEd1cXUKZllFVEVWOVExVStid1B2MkcxRm1yWWdCQjVTTXQ2dHpFZ1hzd0lNQ1BpMmdRdWVwQTFrdDNveGtTQ1VvbWs3bwpIL3BGZ2tGUXIxS0JCRDkxQWFvcDlScmpibE9jSnJMZGVSdFoxWitieU1yb0JIRWdJWmZpCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.79.139.44\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            },
            {
              "key": "cluster-uid",
              "value": "709dc5ccd4484ad3b8b04690bae9b7d2c8f8d2f593944a2db4ac0a8cff76be6e"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke2sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke2-default-pool-2aaf97f7",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "4472888600068904460",
      "creationTimestamp": "2021-12-06T02:41:39.876-08:00",
      "name": "gke-gke2-default-pool-64246ea0",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke2-709dc5cc-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke2-pods-709dc5cc"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "aaySSHS9M-0=",
          "items": [
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            },
            {
              "key": "cluster-uid",
              "value": "709dc5ccd4484ad3b8b04690bae9b7d2c8f8d2f593944a2db4ac0a8cff76be6e"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRWDNvck1HaUU0UnM4Y1hLTUhmd3dUREFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpJQmNOTWpFeE1qQTJNRGswTURVM1doZ1BNakExTVRFeE1qa3hNRFF3TlRkYU1DOHhMVEFyQmdOVkJBTVRKRFJsClpUUTVZbUkwTFdVM09HSXROR1ZtTnkxaU5EQXlMVFkzTmpKaU56ZGhNbVkzTnpDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQU9GdDdXUm1rSlpaMUdvMTd0RzZqNiszRzQrdEEzTlQ1Zm9hVC9TLwpCRFFMNHRyN3E0WnJxYjJlLzFKbVBBemhoY1pmdE1mdTZvdEdZaGg0ZVdyU0lBZ1BiekpSV0pjK1F6Ti9ZODR5CndZL1JCN1g0OGo4YzNvblpMZWN6dzgzTXJKNGgvNFBsTUhEdGx1d2tjaDZCWVJVY04rOW8xZGlycDEySVJpWkIKL25MY1Nib3NTcUZrM0szRzlreE9TTWhEc0RiaVVDR0pMZTk0UjRkK0U3Vm83MGFJMHlrczBFMzNpeDU5Nmd2RwpNYlhxVFNWR29Wck5LNzJ3VHl0cmtSbURsWE11TWhMMmRkTzBXU2RjT2lNQW54K00vVkZjWHNGaWxOUFpLckdhCkVESGlDSGNZUis4TDlvMWhsME93dXBEY2k5akprSmFTWFF6b2dXVnVGUGFqclVzMDFFWWZnOTBpWDZGVS9wQkEKLytmaEhUbEpORkhkb0RXQzFMVyt5Mld3WW12WnRESjUwSlpVYzUwRStpMWRyNVpRN0I0U21zMXd4eFdaWFVpUQp1d1N6Q0VrUWRMZFV3Ti9jUHRYN2hvQndCdmsvTGNvaHN4cTI5RFBNemNkOVUvMUdnbHR4bzRhOG9YaXQ3cmFMCno5WENtcDVGMGF6THNCeVZKOUY0SjE5QTd3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVUxMUh5cWZvalFMWVcwdEtHZEkydElEcTVVR0F3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFGbERoQm1RUXZTSTBvM2drZmhzRVplbEVoUmpGeE8xSCtaUGh1MW5rWGdFClp1MlBXY2pLR0FzRFJOOVRqZ2lqYVo4OUFCd3VMeUUyenY5YmE0U25SYk5ac0NMSFYyR1VGeFNla1BmaVZNZk0KNHlvcWpwS1VTMjNQM05kN1dYQTQ1M1B3QkFIeks4NW1ZRXFreFdtR3Q0WDJLNWluaUM5VGh0UC9mN2xDMnlWeAp3blViUExZUGdrK0pDK1E0bE96bWVIUnpOTnJ0eC9ybCtVYWptSW9iVkpjUHVTZElkWjZiTHdJWWhYRUtCVEVJCnJGbmowWll1SmN2SjdWckYyT2pjZ2REUjZSRkhrcy9EV0g3T1I2dklmbjAwMkxERmt0ZC9WUmc3THV5ekM1NkEKRWxrdGYyNVI5bFRuTmJmOG1RNGt0cWFlQjVLRDJvRnRYNHVleVRORzJXRzc0WTRYaDlkZkZ2Tkgzc0NiRXZqQwpGRTRuUjZWTTRWRTRvNDMrVmJJcERDTDZaYVFick1tTmtrS1dqNzlvZ0ZTeENxUm1VMDZYNUFpY2NXbU5iendtClNuZklsYlF2aXhuOVo1dmI5VTk0eWQwSk1zWnlYcFBtaEdReVZxSnVadG9OSVkraXdNZW1FMFlMbE9TQVFteGYKNndYNC9MeTRNVWhuaFg4UFJwamNjZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.112.0.0/14\nCLUSTER_NAME: gke2\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.116.0.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke2-709dc5cc\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.116.0.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: R_zASgm2sOPE7kJO9HzSig3YNJ_TLBCh73Qd7aF_wDk=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.79.139.44\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.116.0.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRUkxZSm1BRUtGSkdaK3prZVZVV1hJVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKOEgKY25IREkwYm9KcU9IeUZhUGNrSHE5RmF2Uk05UWhUejZtYjB0U1Q5YUJENkphNTk4YUFiUm1lVzdUcHhETFZwdgowL0JTdWdsSEY0NCt6K1VXZUtVbnVCZTVOdm44ZHIweStEdzR3MHVpdGcxMkNEK1lWYmFyZHhJa1pzcnc0UWVaCm9lNlA3NUxQaTFna1RnNVc3alZOTmVxQTZYYTFuQ2swWm5HTFNYSkh4MERDZXAwa21pOGt4RGprKzIxdTdCMk4KV05rZll3QWI3elRsOUFGUTlBV3QrbS9OWElESEVUMTRFcUh5dWVYVFJhUVdWYTIvY0hUaXp3a1QrMWR5ajhuSApwRjdsZEl2aGlxVnFwdlVoR3llNkJRVzcxdWZVaGx5QWN4dW1QK1RuZ0xabTVSSytWMFJFQXhvSW5BOTNGdVpKCkJQNXpLV3l2SWhIOXNDOWxiblVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVTExSHlxZm9qUUxZVwowdEtHZEkydElEcTVVR0F3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUE5RGdrNnhaUXA0WU1IZU9YT0lMQ0xiCjJSL1lZeXFFUnpTS1A2WmduekMzRGpUWTlCV3ZyQ1BXdU9maTZpRkpyUlE4T0JmV2wwZ01EQkMwQmF4djJQRmIKTzZGenByNFIyemxCelVSVTdLWUpucmFuTHhMM05oU1ZTTWRVNnQ4SWNtWmcxSVc4Mm5OVm9OU3lkOHIzZkRLYgpqcCt0bmNlb28veVBJNGhPc1J1aEthTjlHSThPM0JzOUQzODVZNW05RzBOeXJ4c2tjeWJqUUVOSURBdlYyb1NYClFpd01VUXpudFlodWxKc2ZyR1AxdVRRb0pQZkR2OWlnbE1vL0pRem5ESkg1aHdTT1lMZlJTMGRiWUlxUWZOL2MKUjZ3d2JWb004b0FsS1BsZndaRFo4dVJFR3RFQUlHdDdEMFJPeVpiODdMWnNObGNuN1NJZ3VxamNpbnB6b3BMWgowNC83TnoyWEZZWTV3VmVVb2FzOVdnN3JTYU01ZU11QXNBd2NYWU1UOTFqVXEvZ1hxZWlxcUVjSzZPYkZPWUxvCnRIN1JPRnh2V0RUNFVpMDZLZXRDY3hSWnp4Z0E2OUlsbW9xVVVrbUpDRjlkemc5V3I5Z1RMcTliT3BwUUpVM3QKVEg0Vkl2RHozODVrYnYrVW1Rb3JURVhzOWR5UHhKMXh3TmlVT293ZTFBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBbndkeWNjTWpSdWdtbzRmSVZvOXlRZXIwVnE5RXoxQ0ZQUHFadlMxSlAxb0VQb2xyCm4zeG9CdEdaNWJ0T25FTXRXbS9UOEZLNkNVY1hqajdQNVJaNHBTZTRGN2syK2Z4MnZUTDRQRGpEUzZLMkRYWUkKUDVoVnRxdDNFaVJteXZEaEI1bWg3by92a3MrTFdDUk9EbGJ1TlUwMTZvRHBkcldjS1RSbWNZdEpja2ZIUU1KNgpuU1NhTHlURU9PVDdiVzdzSFkxWTJSOWpBQnZ2Tk9YMEFWRDBCYTM2YjgxY2dNY1JQWGdTb2ZLNTVkTkZwQlpWCnJiOXdkT0xQQ1JQN1YzS1B5Y2VrWHVWMGkrR0twV3FtOVNFYko3b0ZCYnZXNTlTR1hJQnpHNlkvNU9lQXRtYmwKRXI1WFJFUURHZ2ljRDNjVzVra0Uvbk1wYks4aUVmMndMMlZ1ZFFJREFRQUJBb0lCQUJkR0VIeHdOYzg0aGdFYwpTOWhKTll4S25iZzYvZHZHV2IySEltMVNmWndKS1VKYXU3YXpUd2tpYno2MUZ5ZmMxL3dhamg2bmlNVDNVODMwClNOb3EyL3kxcjZZL0s3blJ0akh4emUwSVZLS1MzVWhpakFuOG1oeTZBdHJUbTN5YlhKK1BYeWpLQldLTHY4V20KU0lzbU0wWDNOd3NMRXovVmk5Vm03eEF5ZFkwRkU2YktmbVdYdzdxTGNOVzVzMTRlcURSY1pONVRRQllxbXVFegp2eHp2dE5EejlveTNjT1dCci9QOGRaY1RiWGdOMC8rMEs4VEUyaGdCMkV3YnhPT2x6ZDFqM3ZtbUp2K2xtQzhVCmUzenFCcE5FbmN4SjZrQzB6Sml1VFE0TitBWkU2QjlRR0xKOEt2MDVJVGlMd2p4U1hMazZaaWVlTFIzUjI3b2cKZCtDQ2U5RUNnWUVBekNlRlVKQ1hLcVhMSEVtVml1WGZBK1d2Ni9QNHN0Mno2ZkNERnBXTGprT3NueGNPblFObwoweVV3eFZBV09BY3Y0STUybmhULzVyTmhLRlBZbUVWMVI0QkQvMHhsUzliNTJpYmgxZ2d6YjI2bW9rVnVOamtUCnpMbFlySXF3WDIyZzEweU5RcTBsZkR1TzhFZk1vczBwSVZiS3NCV1p3clFGeHRsWUVEUlFKcVVDZ1lFQXgybysKQWJXL3duaDArKzhBbmxzcE45dGtNRkliZGN2NXpJT053Vy93a0QwdFFidGE4TkRxVm9hYnE1UDg0ZDFFNHliZwpCZSswU091bzZ6dE1rQTJ4a3JKTCtraGhNWXBCeTh0a3RVTlhFdVZVdVRuU1YwSlczRTg0dTBLQ0lSUVdZeWdyCnpXVFZWTmRkcDhRQWVOQW9hc2p6QWdBT0RMWjEwSlQ4WmJIbWI1RUNnWUE3VHZQa3pzeUxvRFNjV0Nnd2ZNMUkKRlk4QTdoUis2ZmRkYS9pNU0rS2lCcmo4VXJkMUY4dDVJNkhDZ0p5ajFEcXRjdFcwNFFiaW41UUhJaXlYTi81MQpNaWNPNE1QQXY0aEFQdkYydTFVdDl5aERsZ1lKakpWYThURjRscVhjWXozSnJqeVBkVHVobHEvVTBCYjc2THdkCktsaWh4UFN4WXBrWEJvY1YxZ3krM1FLQmdDaHJuSTMwTFI1YUZEeE13YTlYZ3c5VFpRZDJYU0tQYWQ3T2U1bE4KKzFFQlZYOFJYdW1aTHliQ3VpTVpLQlVRS0xweVVzNWhQQVhiM3Exdm82RS9aVkw2MlBPdVlDVU9oUyt0MW9mMwpVbHIrS1NJeVdqUmR1Z1dGK1ZYYnNVekxLWTZId2Zrc0N5SGJWWngvMmlpaTZNNWNWUVYreFZwR1ViTXB2ODlOCk5BeEJBb0dCQUoyQ1owV0kvM21YaVZnc3B4emE1WnRjb3Z6cUEyVkdVRHh1Q2V4bEhYZWg1Z2dtS21xWEd1cXUKZllFVEVWOVExVStid1B2MkcxRm1yWWdCQjVTTXQ2dHpFZ1hzd0lNQ1BpMmdRdWVwQTFrdDNveGtTQ1VvbWs3bwpIL3BGZ2tGUXIxS0JCRDkxQWFvcDlScmpibE9jSnJMZGVSdFoxWitieU1yb0JIRWdJWmZpCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.116.0.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "cluster-name",
              "value": "gke2"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.79.139.44\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke2sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke2-default-pool-64246ea0",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "3121685970282370572",
      "creationTimestamp": "2021-12-06T02:41:39.809-08:00",
      "name": "gke-gke2-default-pool-94cd5fae",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke2-709dc5cc-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke2-pods-709dc5cc"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "aaySSHS9M-0=",
          "items": [
            {
              "key": "cluster-name",
              "value": "gke2"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRWDNvck1HaUU0UnM4Y1hLTUhmd3dUREFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpJQmNOTWpFeE1qQTJNRGswTURVM1doZ1BNakExTVRFeE1qa3hNRFF3TlRkYU1DOHhMVEFyQmdOVkJBTVRKRFJsClpUUTVZbUkwTFdVM09HSXROR1ZtTnkxaU5EQXlMVFkzTmpKaU56ZGhNbVkzTnpDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQU9GdDdXUm1rSlpaMUdvMTd0RzZqNiszRzQrdEEzTlQ1Zm9hVC9TLwpCRFFMNHRyN3E0WnJxYjJlLzFKbVBBemhoY1pmdE1mdTZvdEdZaGg0ZVdyU0lBZ1BiekpSV0pjK1F6Ti9ZODR5CndZL1JCN1g0OGo4YzNvblpMZWN6dzgzTXJKNGgvNFBsTUhEdGx1d2tjaDZCWVJVY04rOW8xZGlycDEySVJpWkIKL25MY1Nib3NTcUZrM0szRzlreE9TTWhEc0RiaVVDR0pMZTk0UjRkK0U3Vm83MGFJMHlrczBFMzNpeDU5Nmd2RwpNYlhxVFNWR29Wck5LNzJ3VHl0cmtSbURsWE11TWhMMmRkTzBXU2RjT2lNQW54K00vVkZjWHNGaWxOUFpLckdhCkVESGlDSGNZUis4TDlvMWhsME93dXBEY2k5akprSmFTWFF6b2dXVnVGUGFqclVzMDFFWWZnOTBpWDZGVS9wQkEKLytmaEhUbEpORkhkb0RXQzFMVyt5Mld3WW12WnRESjUwSlpVYzUwRStpMWRyNVpRN0I0U21zMXd4eFdaWFVpUQp1d1N6Q0VrUWRMZFV3Ti9jUHRYN2hvQndCdmsvTGNvaHN4cTI5RFBNemNkOVUvMUdnbHR4bzRhOG9YaXQ3cmFMCno5WENtcDVGMGF6THNCeVZKOUY0SjE5QTd3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVUxMUh5cWZvalFMWVcwdEtHZEkydElEcTVVR0F3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFGbERoQm1RUXZTSTBvM2drZmhzRVplbEVoUmpGeE8xSCtaUGh1MW5rWGdFClp1MlBXY2pLR0FzRFJOOVRqZ2lqYVo4OUFCd3VMeUUyenY5YmE0U25SYk5ac0NMSFYyR1VGeFNla1BmaVZNZk0KNHlvcWpwS1VTMjNQM05kN1dYQTQ1M1B3QkFIeks4NW1ZRXFreFdtR3Q0WDJLNWluaUM5VGh0UC9mN2xDMnlWeAp3blViUExZUGdrK0pDK1E0bE96bWVIUnpOTnJ0eC9ybCtVYWptSW9iVkpjUHVTZElkWjZiTHdJWWhYRUtCVEVJCnJGbmowWll1SmN2SjdWckYyT2pjZ2REUjZSRkhrcy9EV0g3T1I2dklmbjAwMkxERmt0ZC9WUmc3THV5ekM1NkEKRWxrdGYyNVI5bFRuTmJmOG1RNGt0cWFlQjVLRDJvRnRYNHVleVRORzJXRzc0WTRYaDlkZkZ2Tkgzc0NiRXZqQwpGRTRuUjZWTTRWRTRvNDMrVmJJcERDTDZaYVFick1tTmtrS1dqNzlvZ0ZTeENxUm1VMDZYNUFpY2NXbU5iendtClNuZklsYlF2aXhuOVo1dmI5VTk0eWQwSk1zWnlYcFBtaEdReVZxSnVadG9OSVkraXdNZW1FMFlMbE9TQVFteGYKNndYNC9MeTRNVWhuaFg4UFJwamNjZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.112.0.0/14\nCLUSTER_NAME: gke2\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.116.0.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke2-709dc5cc\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.116.0.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: R_zASgm2sOPE7kJO9HzSig3YNJ_TLBCh73Qd7aF_wDk=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.79.139.44\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.116.0.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRUkxZSm1BRUtGSkdaK3prZVZVV1hJVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRMFpXVTBPV0ppTkMxbE56aGlMVFJsWmpjdFlqUXdNaTAyTnpZeVlqYzNZVEptTnpjdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKOEgKY25IREkwYm9KcU9IeUZhUGNrSHE5RmF2Uk05UWhUejZtYjB0U1Q5YUJENkphNTk4YUFiUm1lVzdUcHhETFZwdgowL0JTdWdsSEY0NCt6K1VXZUtVbnVCZTVOdm44ZHIweStEdzR3MHVpdGcxMkNEK1lWYmFyZHhJa1pzcnc0UWVaCm9lNlA3NUxQaTFna1RnNVc3alZOTmVxQTZYYTFuQ2swWm5HTFNYSkh4MERDZXAwa21pOGt4RGprKzIxdTdCMk4KV05rZll3QWI3elRsOUFGUTlBV3QrbS9OWElESEVUMTRFcUh5dWVYVFJhUVdWYTIvY0hUaXp3a1QrMWR5ajhuSApwRjdsZEl2aGlxVnFwdlVoR3llNkJRVzcxdWZVaGx5QWN4dW1QK1RuZ0xabTVSSytWMFJFQXhvSW5BOTNGdVpKCkJQNXpLV3l2SWhIOXNDOWxiblVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVTExSHlxZm9qUUxZVwowdEtHZEkydElEcTVVR0F3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUE5RGdrNnhaUXA0WU1IZU9YT0lMQ0xiCjJSL1lZeXFFUnpTS1A2WmduekMzRGpUWTlCV3ZyQ1BXdU9maTZpRkpyUlE4T0JmV2wwZ01EQkMwQmF4djJQRmIKTzZGenByNFIyemxCelVSVTdLWUpucmFuTHhMM05oU1ZTTWRVNnQ4SWNtWmcxSVc4Mm5OVm9OU3lkOHIzZkRLYgpqcCt0bmNlb28veVBJNGhPc1J1aEthTjlHSThPM0JzOUQzODVZNW05RzBOeXJ4c2tjeWJqUUVOSURBdlYyb1NYClFpd01VUXpudFlodWxKc2ZyR1AxdVRRb0pQZkR2OWlnbE1vL0pRem5ESkg1aHdTT1lMZlJTMGRiWUlxUWZOL2MKUjZ3d2JWb004b0FsS1BsZndaRFo4dVJFR3RFQUlHdDdEMFJPeVpiODdMWnNObGNuN1NJZ3VxamNpbnB6b3BMWgowNC83TnoyWEZZWTV3VmVVb2FzOVdnN3JTYU01ZU11QXNBd2NYWU1UOTFqVXEvZ1hxZWlxcUVjSzZPYkZPWUxvCnRIN1JPRnh2V0RUNFVpMDZLZXRDY3hSWnp4Z0E2OUlsbW9xVVVrbUpDRjlkemc5V3I5Z1RMcTliT3BwUUpVM3QKVEg0Vkl2RHozODVrYnYrVW1Rb3JURVhzOWR5UHhKMXh3TmlVT293ZTFBPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBbndkeWNjTWpSdWdtbzRmSVZvOXlRZXIwVnE5RXoxQ0ZQUHFadlMxSlAxb0VQb2xyCm4zeG9CdEdaNWJ0T25FTXRXbS9UOEZLNkNVY1hqajdQNVJaNHBTZTRGN2syK2Z4MnZUTDRQRGpEUzZLMkRYWUkKUDVoVnRxdDNFaVJteXZEaEI1bWg3by92a3MrTFdDUk9EbGJ1TlUwMTZvRHBkcldjS1RSbWNZdEpja2ZIUU1KNgpuU1NhTHlURU9PVDdiVzdzSFkxWTJSOWpBQnZ2Tk9YMEFWRDBCYTM2YjgxY2dNY1JQWGdTb2ZLNTVkTkZwQlpWCnJiOXdkT0xQQ1JQN1YzS1B5Y2VrWHVWMGkrR0twV3FtOVNFYko3b0ZCYnZXNTlTR1hJQnpHNlkvNU9lQXRtYmwKRXI1WFJFUURHZ2ljRDNjVzVra0Uvbk1wYks4aUVmMndMMlZ1ZFFJREFRQUJBb0lCQUJkR0VIeHdOYzg0aGdFYwpTOWhKTll4S25iZzYvZHZHV2IySEltMVNmWndKS1VKYXU3YXpUd2tpYno2MUZ5ZmMxL3dhamg2bmlNVDNVODMwClNOb3EyL3kxcjZZL0s3blJ0akh4emUwSVZLS1MzVWhpakFuOG1oeTZBdHJUbTN5YlhKK1BYeWpLQldLTHY4V20KU0lzbU0wWDNOd3NMRXovVmk5Vm03eEF5ZFkwRkU2YktmbVdYdzdxTGNOVzVzMTRlcURSY1pONVRRQllxbXVFegp2eHp2dE5EejlveTNjT1dCci9QOGRaY1RiWGdOMC8rMEs4VEUyaGdCMkV3YnhPT2x6ZDFqM3ZtbUp2K2xtQzhVCmUzenFCcE5FbmN4SjZrQzB6Sml1VFE0TitBWkU2QjlRR0xKOEt2MDVJVGlMd2p4U1hMazZaaWVlTFIzUjI3b2cKZCtDQ2U5RUNnWUVBekNlRlVKQ1hLcVhMSEVtVml1WGZBK1d2Ni9QNHN0Mno2ZkNERnBXTGprT3NueGNPblFObwoweVV3eFZBV09BY3Y0STUybmhULzVyTmhLRlBZbUVWMVI0QkQvMHhsUzliNTJpYmgxZ2d6YjI2bW9rVnVOamtUCnpMbFlySXF3WDIyZzEweU5RcTBsZkR1TzhFZk1vczBwSVZiS3NCV1p3clFGeHRsWUVEUlFKcVVDZ1lFQXgybysKQWJXL3duaDArKzhBbmxzcE45dGtNRkliZGN2NXpJT053Vy93a0QwdFFidGE4TkRxVm9hYnE1UDg0ZDFFNHliZwpCZSswU091bzZ6dE1rQTJ4a3JKTCtraGhNWXBCeTh0a3RVTlhFdVZVdVRuU1YwSlczRTg0dTBLQ0lSUVdZeWdyCnpXVFZWTmRkcDhRQWVOQW9hc2p6QWdBT0RMWjEwSlQ4WmJIbWI1RUNnWUE3VHZQa3pzeUxvRFNjV0Nnd2ZNMUkKRlk4QTdoUis2ZmRkYS9pNU0rS2lCcmo4VXJkMUY4dDVJNkhDZ0p5ajFEcXRjdFcwNFFiaW41UUhJaXlYTi81MQpNaWNPNE1QQXY0aEFQdkYydTFVdDl5aERsZ1lKakpWYThURjRscVhjWXozSnJqeVBkVHVobHEvVTBCYjc2THdkCktsaWh4UFN4WXBrWEJvY1YxZ3krM1FLQmdDaHJuSTMwTFI1YUZEeE13YTlYZ3c5VFpRZDJYU0tQYWQ3T2U1bE4KKzFFQlZYOFJYdW1aTHliQ3VpTVpLQlVRS0xweVVzNWhQQVhiM3Exdm82RS9aVkw2MlBPdVlDVU9oUyt0MW9mMwpVbHIrS1NJeVdqUmR1Z1dGK1ZYYnNVekxLWTZId2Zrc0N5SGJWWngvMmlpaTZNNWNWUVYreFZwR1ViTXB2ODlOCk5BeEJBb0dCQUoyQ1owV0kvM21YaVZnc3B4emE1WnRjb3Z6cUEyVkdVRHh1Q2V4bEhYZWg1Z2dtS21xWEd1cXUKZllFVEVWOVExVStid1B2MkcxRm1yWWdCQjVTTXQ2dHpFZ1hzd0lNQ1BpMmdRdWVwQTFrdDNveGtTQ1VvbWs3bwpIL3BGZ2tGUXIxS0JCRDkxQWFvcDlScmpibE9jSnJMZGVSdFoxWitieU1yb0JIRWdJWmZpCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.116.0.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.79.139.44\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "cluster-uid",
              "value": "709dc5ccd4484ad3b8b04690bae9b7d2c8f8d2f593944a2db4ac0a8cff76be6e"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke2sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke2-default-pool-94cd5fae",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "4141805170541483538",
      "creationTimestamp": "2021-12-06T02:42:05.167-08:00",
      "name": "gke-gke3-default-pool-3ebd9862",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke3-c0f5e27c-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke3-pods-c0f5e27c"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "0Tu-9ScQjDw=",
          "items": [
            {
              "key": "cluster-name",
              "value": "gke3"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMVENDQXBXZ0F3SUJBZ0lSQU83d1QwZE04aWRxYmd6SmVydUhncEV3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa01EWmxOalkyWm1NdFlUZ3lZaTAwTm1Ka0xUaGxOVGd0WlRjd05ESXhZVGhoTnpVeApNQ0FYRFRJeE1USXdOakE1TkRBMU4xb1lEekl3TlRFeE1USTVNVEEwTURVM1dqQXZNUzB3S3dZRFZRUURFeVF3Ck5tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFd2dnR2lNQTBHQ1NxR1NJYjMKRFFFQkFRVUFBNElCandBd2dnR0tBb0lCZ1FDZWdpeWVRSWk3d1J4bUhjUE9lZkJGS2dPckVFV0p4aVNmejlmWAo0R1Y2NzBFT0FGam1hSWVNRDU0NlJ0MXVrdktGQXJ1Z2dOSGZzVXNrS0tMTm1zS1ZGaEIxR0p3SWpaWXF5ampECkhGUld0bm9mQTI4cUwzVlFqOFhaaFZHNU5PV3l2U0dtRnZ3eXo3T2RmKzBoQmJERWcwb2xvSU9WdnBXNzNReGkKS3p0dE00SzJ1a0ZtbmVUN0gvLytKTDErQmptdFUyVy9GSnZaKzJZdDNJU1R4OXlMbTM4RFIxaVhRYnRpQUNRegpJSzlraVpOMThQZU5YMDYyK3cyQWxXZWtPK1k1bFNlYUJrbW1YUDltTVl5WU4xblZhcHFCaU9DRGwwc0lqUzROCllRYnVwM2tieEliUW1Rd0x6K3dRYXQxcm95WmZqUWFtb3BRNUFYZ243TjZiRlJuVjljMW5FZERUSm42NkNpbUwKd2hlZHN0cEVLV2Zxb0VyY2l4a09Qdk5pSjJOQUVnSFZvcWZZUHlGRUJPMVdOZEpaNGphcTF6L3BDVCttTmszVQpJY1JrZ1pqVWE5Wkp3bUFNbkVIMndreWdDZDdxaWtVZGNTUlVKRG5JUUJJbTFIdkNsSFJaYmlSeWphY2dMK2V6CjNYbktVMXR5ZVRCd2RUSnRNTU85TllmTGFFOENBd0VBQWFOQ01FQXdEZ1lEVlIwUEFRSC9CQVFEQWdJRU1BOEcKQTFVZEV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGRnlVUU1mSnBqVWU0dVNDbWlZREMxbUdkdzEyTUEwRwpDU3FHU0liM0RRRUJDd1VBQTRJQmdRQ0hTUW9ldE9mc0tSWjVzUnNxMnBuODJNR2IxbjJScENzbGZoeDYzMFJMCllzVkZTQmZFSU1FaTYrRXhzY2I5SUEwMmJTZGtwTXlUU3p1TElna3FzQnZMR2NyMXFlN2NWaXM3N2tJelN6TTkKMWFLOFVLVzEwS052WkZqTXppOWJGM2FGS2tqUExxM2JBTkRUd21PT1pGVkk2V3Z4d0NBLytsRm9FUGY4OE52UwpGbmx6K0Y3dXp0YkRFTzY2Y1dCTk9PUlR4UFoxK0RnM25lNGNOWGdXNmNJYUlFZ2dhMWM1RTlPeUY3aG5WVVRRCmRpWlFFMDUvKzN4d2hVWEFIeWNuenNlYS9YVncwamhZR2JXWHY0UVNySzA3TFhZMm9qYzVBVnZVOXNnUXJwS0cKSG1BY1czeVNrcEFWUnlQVEJBWFBtZzljaWFzQjlxNC9RL3YxcXg4NkMrcWJaaVVDRGFMdUdrR0pqTEVMN2dMdAprWEdRUDUzRGxlM0pyQzhHM2pzSG12aHFCd3dyN0xDTDRMcG9iam9weTUxU25GZ2tIWmtsdWVvWXpGbXR3MEtpCkt2bUgra1lkZCt5SkFWNmJOSEFpN0hEc21HcitEdUk1MnJNNzRiSzlCWHVTWlVLWGxkdEEvRkJXWTI3a3FadkIKRytwUHVzRjR0TXZsYU9CUi95QnlWbHM9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.64.0.0/14\nCLUSTER_NAME: gke3\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.62.160.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke3-c0f5e27c\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.62.160.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: uS5YsWeVYno-2TTFKWXjg2sn5tx9i2MjrXZ8RL0uv40=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.140.223.163\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.62.160.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRVFl4WTNnRTlGcUNjQTRnWXhWMXdVVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRd05tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFNQkoKdXUvWDVHYzRuVDN6VkNVS1pNYk8xWXhKSVNHdW1OeWZaeFlQZnpsUGs1eWFBejA2cGM0bGtPTkhKL21Na1hSMQpUUTZ1NGFWUk52UUY0aVQ1Q0RVcU0yRVFmTVZiVnQwY3F2ZzRsSkIwSlhhQXAyTk8zcjd6enptcVBQRzVrSS9yCmlJRWZySzBHa09lUmdicGI4dlIrcmR5NWlxMmhRK2pEcVBSeFRtUVNEUGt1UTNUVVNraWhNRnRubFhYL3R5TEUKdTBBSWdjcjV1YWFTS1FsVEFYUloyV25jbWpDWkhCaXlSZ3NZQmxYdnAvVDRmemd1a1EyOU5JK0hiY2FiaVJiTgpUTms5VjVhRzdXSkhUV04rZ0hhamZEdHJsaXZKSklyMVo3Nmc3b2xvOXV6eWIwVEswaGgrRGlxL0JSQjRjN2E5Ck5lUk50bzJ2bnl5UjFObE1aMEVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVVhKUkF4OG1tTlI3aQo1SUthSmdNTFdZWjNEWFl3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUJCUDBDSXpDanRvQkhJNVlQYzJTOHlWCm4wKzU4czhXenR4UXU4Wk5IRFFzMUZ0SFNhRWkwdGREUE5kbGhOdXY3RkRKY2ViQk5JTVlzc2tZMzZad2ZaZ28KZis3WmduajJMMHF6MHJxZjlJa0IyRWFBdTlVQkRpWnNwblA5cGo4SFlFR29pUys0dHR5MXNzVm54WXUraDUvWgo2UENmbzZ2c2JoanBaTThuZjlRWVRNV1ZheG4wRnNvdjlpL21ySndCSHFwTzJVb1Uwa0oyakE0R25Nc3VST0YwCllDWHFqR3JrOTBqaWJLNms5aXFmNFRMWnBhcjFwUlRhQzBvUGhIcWVIYUNHWGtrSFRGQ3pkenFMQTlXQmh1UDUKTllJZUNHblJ1U2JmZE13VWR2VTZiWjM3L0ZxdWtFYWRTeGpWNHJJM2tOWExmRUZDb3hxYkt2VzJKcGYwcy8rdwp3cHZmNVRxc0crdjJvYW80VlMxaDBoTTNWdU9VMFlubFI5OXdZMFpXNkhwQm1FOVVJOHFtZlJ4b1VFQUJrcElQCm9UWUxqQUdhYXdPZ1lEMU04dkJZNU9rV3FKdTdCZWIxODA1dThDWEhUOWRqL1BKS2dZN01OUkhhQTNNb3llc0cKTk80TnZPaWViZkR1M1h0ZTlXVmx6UFYyNlFSMDFyR2NUTFFBRWZKZTZRPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBd0VtNjc5ZmtaemlkUGZOVUpRcGt4czdWakVraElhNlkzSjluRmc5L09VK1RuSm9EClBUcWx6aVdRNDBjbitZeVJkSFZORHE3aHBWRTI5QVhpSlBrSU5Tb3pZUkI4eFZ0VzNSeXErRGlVa0hRbGRvQ24KWTA3ZXZ2UFBPYW84OGJtUWordUlnUitzclFhUTU1R0J1bHZ5OUg2dDNMbUtyYUZENk1PbzlIRk9aQklNK1M1RApkTlJLU0tFd1cyZVZkZiszSXNTN1FBaUJ5dm01cHBJcENWTUJkRm5aYWR5YU1Ka2NHTEpHQ3hnR1ZlK245UGgvCk9DNlJEYjAwajRkdHhwdUpGczFNMlQxWGxvYnRZa2ROWTM2QWRxTjhPMnVXSzhra2l2Vm52cUR1aVdqMjdQSnYKUk1yU0dINE9LcjhGRUhoenRyMDE1RTIyamErZkxKSFUyVXhuUVFJREFRQUJBb0lCQUNlajY0QS9Vd3crZlJnRQozajltbGFEd2lkQ0tVT1MzTURjbk8yS3VYaTFyN01QWGNqeUFweWJJMHNZdjZKdEc4Y04rM1J4ZVRCRS9IV09RCkJPOVhVV3hZWDFBdXpISUpJdTZoVnRPbUltWm5NMFByUU5hMXJ6RFJaVkovZUdIaXZkMFZrc1gveUNMQlhFVUkKMTZRYUNZdUN4QWZoVGlmK08xZzBZZFBHdWdEaDVrRFh4ZVR1aEdKRmRCT3B0djBmYWh5c2Z0alNURnBXbUNKNAovcXZsOGllWTZuV3JwTDlseXFYZnNqK25VRjdNOTgwd2szM1I2VHI1bjVRVGhIOGFxRTRVVXdGRm9mZThXT1hLCmtJKzVnUW11WWhLQkROY2pyNlZFakY2am5teVhNS0NlRElqNTJuYkVqOFo2cjIxSEVqV2xjYmo0R2c0L3VFbkkKVXMxSGJpTUNnWUVBNGtTMlRYUnpjVlpLRkFWakt1Mi80RlZ4cWxLKzcyeU9icVZlK2kyMDVLZWFPRnpxOVRoeAp6Yi9PTXF3UG9JeDNsSS94eXVkS0pIUHYrMzI2NFBOOTRUeGhML0lIVXY4SThMSGJDTzRUT1cvclllQTVMeUJHClBaQ2lQS1czbTU0bGpkVlFnRXR4R2RHS09KTjFTZmlwV3BzcnFnY29oV2FySDg3TTM4bGo5L3NDZ1lFQTJZMzUKaXhubk8xUndOZUt1OEJVWDVyZUZ3djhPM2VtdUd0Mk9UV1VjK3JZTUYvVmhQZFZZUzdxdmg2akpueWFMdVI5TworcHM4ekR3UlN4MHFpQ3VxM25uNU1MaWZ5cmVIRWZtUVZDUnUzMlVYb0NsSThjTG10MUxzVUpVejJKaENLaytmCkNCSUt5RnlsMEcrdjNSRmdSNVZrcTRKUGtibVJRUE5td1N1a3pQTUNnWUEwdUZuWnRqWm53L2xDclBhc08vVW4KS2dGdjlCTzA2WkJPUzQzVHNPNmpFRUlvdTgyckVWbkMzTndJaG5xbHA5VDg4b1VlQjhJSXVGTEVRRWxZdktNcAo1YzJuUkRkY3FUdkdDVXJGeStNQzBRY0JLU05welpWUUp2RUdQSDZKYmRIR09GdW5hT3lUWFhWZE5VNXd5OVY1CjNRblJkaFdFNzZVVHBqV3FOdHhxSFFLQmdRQ0t0djdsRmFnZGFWSisyVUhIN1BzbmJkOEpIVTRpYXN4TGJ2YzgKRy91bFZBeFQvbTU1V1o0SjgwZldqT1c1NTM3eGs2ZnRIS3hnWVBCNTMyZnVHVUhDeHl6L1Jza0VIWTh2QTl4bAorakVEbWRhOWxYVmdTWENJZFlRZVFYUWtaN2pRZDZJa0tEVGQyazBUb1JNV051MFgxNGF2NE0vUlQrdnc2UUdjCnE3SlJ4d0tCZ0JEbTVqMUV2T2ZDWnBUVnFTS0QwUGp4L21aaDNLUWJpcXFFT005WjBybXI0QW14b2k0S2x0Uk4KQ2R2eDY0KzFFdmduUmVKdmdzVXhYZnZURjF6bXVzS3JQcjZNYVZQY0hiQlh0VEl5WjZwWjVrYnY4bXJ3L0NkTQpkalhkRFg3dDJiZUsycFJCSEhXUjdRRXphNzZkSFJ1cTBYeXJpbWxodzQ4T3pHZ0oxdlVQCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.140.223.163\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "cluster-uid",
              "value": "c0f5e27c315747198203f0e6fe9a0f718077710bb58145f588e137046f133d7a"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.62.160.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke3sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke3-default-pool-3ebd9862",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "8207787178508441106",
      "creationTimestamp": "2021-12-06T02:42:05.138-08:00",
      "name": "gke-gke3-default-pool-6da04475",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke3-c0f5e27c-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke3-pods-c0f5e27c"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "0Tu-9ScQjDw=",
          "items": [
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            },
            {
              "key": "cluster-uid",
              "value": "c0f5e27c315747198203f0e6fe9a0f718077710bb58145f588e137046f133d7a"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.62.160.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMVENDQXBXZ0F3SUJBZ0lSQU83d1QwZE04aWRxYmd6SmVydUhncEV3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa01EWmxOalkyWm1NdFlUZ3lZaTAwTm1Ka0xUaGxOVGd0WlRjd05ESXhZVGhoTnpVeApNQ0FYRFRJeE1USXdOakE1TkRBMU4xb1lEekl3TlRFeE1USTVNVEEwTURVM1dqQXZNUzB3S3dZRFZRUURFeVF3Ck5tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFd2dnR2lNQTBHQ1NxR1NJYjMKRFFFQkFRVUFBNElCandBd2dnR0tBb0lCZ1FDZWdpeWVRSWk3d1J4bUhjUE9lZkJGS2dPckVFV0p4aVNmejlmWAo0R1Y2NzBFT0FGam1hSWVNRDU0NlJ0MXVrdktGQXJ1Z2dOSGZzVXNrS0tMTm1zS1ZGaEIxR0p3SWpaWXF5ampECkhGUld0bm9mQTI4cUwzVlFqOFhaaFZHNU5PV3l2U0dtRnZ3eXo3T2RmKzBoQmJERWcwb2xvSU9WdnBXNzNReGkKS3p0dE00SzJ1a0ZtbmVUN0gvLytKTDErQmptdFUyVy9GSnZaKzJZdDNJU1R4OXlMbTM4RFIxaVhRYnRpQUNRegpJSzlraVpOMThQZU5YMDYyK3cyQWxXZWtPK1k1bFNlYUJrbW1YUDltTVl5WU4xblZhcHFCaU9DRGwwc0lqUzROCllRYnVwM2tieEliUW1Rd0x6K3dRYXQxcm95WmZqUWFtb3BRNUFYZ243TjZiRlJuVjljMW5FZERUSm42NkNpbUwKd2hlZHN0cEVLV2Zxb0VyY2l4a09Qdk5pSjJOQUVnSFZvcWZZUHlGRUJPMVdOZEpaNGphcTF6L3BDVCttTmszVQpJY1JrZ1pqVWE5Wkp3bUFNbkVIMndreWdDZDdxaWtVZGNTUlVKRG5JUUJJbTFIdkNsSFJaYmlSeWphY2dMK2V6CjNYbktVMXR5ZVRCd2RUSnRNTU85TllmTGFFOENBd0VBQWFOQ01FQXdEZ1lEVlIwUEFRSC9CQVFEQWdJRU1BOEcKQTFVZEV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGRnlVUU1mSnBqVWU0dVNDbWlZREMxbUdkdzEyTUEwRwpDU3FHU0liM0RRRUJDd1VBQTRJQmdRQ0hTUW9ldE9mc0tSWjVzUnNxMnBuODJNR2IxbjJScENzbGZoeDYzMFJMCllzVkZTQmZFSU1FaTYrRXhzY2I5SUEwMmJTZGtwTXlUU3p1TElna3FzQnZMR2NyMXFlN2NWaXM3N2tJelN6TTkKMWFLOFVLVzEwS052WkZqTXppOWJGM2FGS2tqUExxM2JBTkRUd21PT1pGVkk2V3Z4d0NBLytsRm9FUGY4OE52UwpGbmx6K0Y3dXp0YkRFTzY2Y1dCTk9PUlR4UFoxK0RnM25lNGNOWGdXNmNJYUlFZ2dhMWM1RTlPeUY3aG5WVVRRCmRpWlFFMDUvKzN4d2hVWEFIeWNuenNlYS9YVncwamhZR2JXWHY0UVNySzA3TFhZMm9qYzVBVnZVOXNnUXJwS0cKSG1BY1czeVNrcEFWUnlQVEJBWFBtZzljaWFzQjlxNC9RL3YxcXg4NkMrcWJaaVVDRGFMdUdrR0pqTEVMN2dMdAprWEdRUDUzRGxlM0pyQzhHM2pzSG12aHFCd3dyN0xDTDRMcG9iam9weTUxU25GZ2tIWmtsdWVvWXpGbXR3MEtpCkt2bUgra1lkZCt5SkFWNmJOSEFpN0hEc21HcitEdUk1MnJNNzRiSzlCWHVTWlVLWGxkdEEvRkJXWTI3a3FadkIKRytwUHVzRjR0TXZsYU9CUi95QnlWbHM9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.64.0.0/14\nCLUSTER_NAME: gke3\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.62.160.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke3-c0f5e27c\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.62.160.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: uS5YsWeVYno-2TTFKWXjg2sn5tx9i2MjrXZ8RL0uv40=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.140.223.163\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.62.160.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRVFl4WTNnRTlGcUNjQTRnWXhWMXdVVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRd05tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFNQkoKdXUvWDVHYzRuVDN6VkNVS1pNYk8xWXhKSVNHdW1OeWZaeFlQZnpsUGs1eWFBejA2cGM0bGtPTkhKL21Na1hSMQpUUTZ1NGFWUk52UUY0aVQ1Q0RVcU0yRVFmTVZiVnQwY3F2ZzRsSkIwSlhhQXAyTk8zcjd6enptcVBQRzVrSS9yCmlJRWZySzBHa09lUmdicGI4dlIrcmR5NWlxMmhRK2pEcVBSeFRtUVNEUGt1UTNUVVNraWhNRnRubFhYL3R5TEUKdTBBSWdjcjV1YWFTS1FsVEFYUloyV25jbWpDWkhCaXlSZ3NZQmxYdnAvVDRmemd1a1EyOU5JK0hiY2FiaVJiTgpUTms5VjVhRzdXSkhUV04rZ0hhamZEdHJsaXZKSklyMVo3Nmc3b2xvOXV6eWIwVEswaGgrRGlxL0JSQjRjN2E5Ck5lUk50bzJ2bnl5UjFObE1aMEVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVVhKUkF4OG1tTlI3aQo1SUthSmdNTFdZWjNEWFl3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUJCUDBDSXpDanRvQkhJNVlQYzJTOHlWCm4wKzU4czhXenR4UXU4Wk5IRFFzMUZ0SFNhRWkwdGREUE5kbGhOdXY3RkRKY2ViQk5JTVlzc2tZMzZad2ZaZ28KZis3WmduajJMMHF6MHJxZjlJa0IyRWFBdTlVQkRpWnNwblA5cGo4SFlFR29pUys0dHR5MXNzVm54WXUraDUvWgo2UENmbzZ2c2JoanBaTThuZjlRWVRNV1ZheG4wRnNvdjlpL21ySndCSHFwTzJVb1Uwa0oyakE0R25Nc3VST0YwCllDWHFqR3JrOTBqaWJLNms5aXFmNFRMWnBhcjFwUlRhQzBvUGhIcWVIYUNHWGtrSFRGQ3pkenFMQTlXQmh1UDUKTllJZUNHblJ1U2JmZE13VWR2VTZiWjM3L0ZxdWtFYWRTeGpWNHJJM2tOWExmRUZDb3hxYkt2VzJKcGYwcy8rdwp3cHZmNVRxc0crdjJvYW80VlMxaDBoTTNWdU9VMFlubFI5OXdZMFpXNkhwQm1FOVVJOHFtZlJ4b1VFQUJrcElQCm9UWUxqQUdhYXdPZ1lEMU04dkJZNU9rV3FKdTdCZWIxODA1dThDWEhUOWRqL1BKS2dZN01OUkhhQTNNb3llc0cKTk80TnZPaWViZkR1M1h0ZTlXVmx6UFYyNlFSMDFyR2NUTFFBRWZKZTZRPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBd0VtNjc5ZmtaemlkUGZOVUpRcGt4czdWakVraElhNlkzSjluRmc5L09VK1RuSm9EClBUcWx6aVdRNDBjbitZeVJkSFZORHE3aHBWRTI5QVhpSlBrSU5Tb3pZUkI4eFZ0VzNSeXErRGlVa0hRbGRvQ24KWTA3ZXZ2UFBPYW84OGJtUWordUlnUitzclFhUTU1R0J1bHZ5OUg2dDNMbUtyYUZENk1PbzlIRk9aQklNK1M1RApkTlJLU0tFd1cyZVZkZiszSXNTN1FBaUJ5dm01cHBJcENWTUJkRm5aYWR5YU1Ka2NHTEpHQ3hnR1ZlK245UGgvCk9DNlJEYjAwajRkdHhwdUpGczFNMlQxWGxvYnRZa2ROWTM2QWRxTjhPMnVXSzhra2l2Vm52cUR1aVdqMjdQSnYKUk1yU0dINE9LcjhGRUhoenRyMDE1RTIyamErZkxKSFUyVXhuUVFJREFRQUJBb0lCQUNlajY0QS9Vd3crZlJnRQozajltbGFEd2lkQ0tVT1MzTURjbk8yS3VYaTFyN01QWGNqeUFweWJJMHNZdjZKdEc4Y04rM1J4ZVRCRS9IV09RCkJPOVhVV3hZWDFBdXpISUpJdTZoVnRPbUltWm5NMFByUU5hMXJ6RFJaVkovZUdIaXZkMFZrc1gveUNMQlhFVUkKMTZRYUNZdUN4QWZoVGlmK08xZzBZZFBHdWdEaDVrRFh4ZVR1aEdKRmRCT3B0djBmYWh5c2Z0alNURnBXbUNKNAovcXZsOGllWTZuV3JwTDlseXFYZnNqK25VRjdNOTgwd2szM1I2VHI1bjVRVGhIOGFxRTRVVXdGRm9mZThXT1hLCmtJKzVnUW11WWhLQkROY2pyNlZFakY2am5teVhNS0NlRElqNTJuYkVqOFo2cjIxSEVqV2xjYmo0R2c0L3VFbkkKVXMxSGJpTUNnWUVBNGtTMlRYUnpjVlpLRkFWakt1Mi80RlZ4cWxLKzcyeU9icVZlK2kyMDVLZWFPRnpxOVRoeAp6Yi9PTXF3UG9JeDNsSS94eXVkS0pIUHYrMzI2NFBOOTRUeGhML0lIVXY4SThMSGJDTzRUT1cvclllQTVMeUJHClBaQ2lQS1czbTU0bGpkVlFnRXR4R2RHS09KTjFTZmlwV3BzcnFnY29oV2FySDg3TTM4bGo5L3NDZ1lFQTJZMzUKaXhubk8xUndOZUt1OEJVWDVyZUZ3djhPM2VtdUd0Mk9UV1VjK3JZTUYvVmhQZFZZUzdxdmg2akpueWFMdVI5TworcHM4ekR3UlN4MHFpQ3VxM25uNU1MaWZ5cmVIRWZtUVZDUnUzMlVYb0NsSThjTG10MUxzVUpVejJKaENLaytmCkNCSUt5RnlsMEcrdjNSRmdSNVZrcTRKUGtibVJRUE5td1N1a3pQTUNnWUEwdUZuWnRqWm53L2xDclBhc08vVW4KS2dGdjlCTzA2WkJPUzQzVHNPNmpFRUlvdTgyckVWbkMzTndJaG5xbHA5VDg4b1VlQjhJSXVGTEVRRWxZdktNcAo1YzJuUkRkY3FUdkdDVXJGeStNQzBRY0JLU05welpWUUp2RUdQSDZKYmRIR09GdW5hT3lUWFhWZE5VNXd5OVY1CjNRblJkaFdFNzZVVHBqV3FOdHhxSFFLQmdRQ0t0djdsRmFnZGFWSisyVUhIN1BzbmJkOEpIVTRpYXN4TGJ2YzgKRy91bFZBeFQvbTU1V1o0SjgwZldqT1c1NTM3eGs2ZnRIS3hnWVBCNTMyZnVHVUhDeHl6L1Jza0VIWTh2QTl4bAorakVEbWRhOWxYVmdTWENJZFlRZVFYUWtaN2pRZDZJa0tEVGQyazBUb1JNV051MFgxNGF2NE0vUlQrdnc2UUdjCnE3SlJ4d0tCZ0JEbTVqMUV2T2ZDWnBUVnFTS0QwUGp4L21aaDNLUWJpcXFFT005WjBybXI0QW14b2k0S2x0Uk4KQ2R2eDY0KzFFdmduUmVKdmdzVXhYZnZURjF6bXVzS3JQcjZNYVZQY0hiQlh0VEl5WjZwWjVrYnY4bXJ3L0NkTQpkalhkRFg3dDJiZUsycFJCSEhXUjdRRXphNzZkSFJ1cTBYeXJpbWxodzQ4T3pHZ0oxdlVQCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "cluster-name",
              "value": "gke3"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.140.223.163\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke3sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke3-default-pool-6da04475",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "7807107111074158098",
      "creationTimestamp": "2021-12-06T02:42:05.104-08:00",
      "name": "gke-gke3-default-pool-8e8d9ac3",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke3-c0f5e27c-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west1/subnetworks/default",
            "name": "nic0",
            "accessConfigs": [
              {
                "type": "ONE_TO_ONE_NAT",
                "name": "external-nat",
                "networkTier": "PREMIUM",
                "kind": "compute#accessConfig"
              }
            ],
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke3-pods-c0f5e27c"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "0Tu-9ScQjDw=",
          "items": [
            {
              "key": "cluster-name",
              "value": "gke3"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "enable-oslogin",
              "value": "false"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMVENDQXBXZ0F3SUJBZ0lSQU83d1QwZE04aWRxYmd6SmVydUhncEV3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa01EWmxOalkyWm1NdFlUZ3lZaTAwTm1Ka0xUaGxOVGd0WlRjd05ESXhZVGhoTnpVeApNQ0FYRFRJeE1USXdOakE1TkRBMU4xb1lEekl3TlRFeE1USTVNVEEwTURVM1dqQXZNUzB3S3dZRFZRUURFeVF3Ck5tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFd2dnR2lNQTBHQ1NxR1NJYjMKRFFFQkFRVUFBNElCandBd2dnR0tBb0lCZ1FDZWdpeWVRSWk3d1J4bUhjUE9lZkJGS2dPckVFV0p4aVNmejlmWAo0R1Y2NzBFT0FGam1hSWVNRDU0NlJ0MXVrdktGQXJ1Z2dOSGZzVXNrS0tMTm1zS1ZGaEIxR0p3SWpaWXF5ampECkhGUld0bm9mQTI4cUwzVlFqOFhaaFZHNU5PV3l2U0dtRnZ3eXo3T2RmKzBoQmJERWcwb2xvSU9WdnBXNzNReGkKS3p0dE00SzJ1a0ZtbmVUN0gvLytKTDErQmptdFUyVy9GSnZaKzJZdDNJU1R4OXlMbTM4RFIxaVhRYnRpQUNRegpJSzlraVpOMThQZU5YMDYyK3cyQWxXZWtPK1k1bFNlYUJrbW1YUDltTVl5WU4xblZhcHFCaU9DRGwwc0lqUzROCllRYnVwM2tieEliUW1Rd0x6K3dRYXQxcm95WmZqUWFtb3BRNUFYZ243TjZiRlJuVjljMW5FZERUSm42NkNpbUwKd2hlZHN0cEVLV2Zxb0VyY2l4a09Qdk5pSjJOQUVnSFZvcWZZUHlGRUJPMVdOZEpaNGphcTF6L3BDVCttTmszVQpJY1JrZ1pqVWE5Wkp3bUFNbkVIMndreWdDZDdxaWtVZGNTUlVKRG5JUUJJbTFIdkNsSFJaYmlSeWphY2dMK2V6CjNYbktVMXR5ZVRCd2RUSnRNTU85TllmTGFFOENBd0VBQWFOQ01FQXdEZ1lEVlIwUEFRSC9CQVFEQWdJRU1BOEcKQTFVZEV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGRnlVUU1mSnBqVWU0dVNDbWlZREMxbUdkdzEyTUEwRwpDU3FHU0liM0RRRUJDd1VBQTRJQmdRQ0hTUW9ldE9mc0tSWjVzUnNxMnBuODJNR2IxbjJScENzbGZoeDYzMFJMCllzVkZTQmZFSU1FaTYrRXhzY2I5SUEwMmJTZGtwTXlUU3p1TElna3FzQnZMR2NyMXFlN2NWaXM3N2tJelN6TTkKMWFLOFVLVzEwS052WkZqTXppOWJGM2FGS2tqUExxM2JBTkRUd21PT1pGVkk2V3Z4d0NBLytsRm9FUGY4OE52UwpGbmx6K0Y3dXp0YkRFTzY2Y1dCTk9PUlR4UFoxK0RnM25lNGNOWGdXNmNJYUlFZ2dhMWM1RTlPeUY3aG5WVVRRCmRpWlFFMDUvKzN4d2hVWEFIeWNuenNlYS9YVncwamhZR2JXWHY0UVNySzA3TFhZMm9qYzVBVnZVOXNnUXJwS0cKSG1BY1czeVNrcEFWUnlQVEJBWFBtZzljaWFzQjlxNC9RL3YxcXg4NkMrcWJaaVVDRGFMdUdrR0pqTEVMN2dMdAprWEdRUDUzRGxlM0pyQzhHM2pzSG12aHFCd3dyN0xDTDRMcG9iam9weTUxU25GZ2tIWmtsdWVvWXpGbXR3MEtpCkt2bUgra1lkZCt5SkFWNmJOSEFpN0hEc21HcitEdUk1MnJNNzRiSzlCWHVTWlVLWGxkdEEvRkJXWTI3a3FadkIKRytwUHVzRjR0TXZsYU9CUi95QnlWbHM9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.64.0.0/14\nCLUSTER_NAME: gke3\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.62.160.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke3-c0f5e27c\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.62.160.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: uS5YsWeVYno-2TTFKWXjg2sn5tx9i2MjrXZ8RL0uv40=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 34.140.223.163\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.62.160.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURxekNDQWhPZ0F3SUJBZ0lRVFl4WTNnRTlGcUNjQTRnWXhWMXdVVEFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlRd05tVTJOalptWXkxaE9ESmlMVFEyWW1RdE9HVTFPQzFsTnpBME1qRmhPR0UzTlRFdwpIaGNOTWpFeE1qQTJNVEEwTURVNFdoY05Nall4TWpBMU1UQTBNRFU0V2pBY01Sb3dHQVlEVlFRREV4RnJkV0psCmJHVjBMV0p2YjNSemRISmhjRENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFNQkoKdXUvWDVHYzRuVDN6VkNVS1pNYk8xWXhKSVNHdW1OeWZaeFlQZnpsUGs1eWFBejA2cGM0bGtPTkhKL21Na1hSMQpUUTZ1NGFWUk52UUY0aVQ1Q0RVcU0yRVFmTVZiVnQwY3F2ZzRsSkIwSlhhQXAyTk8zcjd6enptcVBQRzVrSS9yCmlJRWZySzBHa09lUmdicGI4dlIrcmR5NWlxMmhRK2pEcVBSeFRtUVNEUGt1UTNUVVNraWhNRnRubFhYL3R5TEUKdTBBSWdjcjV1YWFTS1FsVEFYUloyV25jbWpDWkhCaXlSZ3NZQmxYdnAvVDRmemd1a1EyOU5JK0hiY2FiaVJiTgpUTms5VjVhRzdXSkhUV04rZ0hhamZEdHJsaXZKSklyMVo3Nmc3b2xvOXV6eWIwVEswaGgrRGlxL0JSQjRjN2E5Ck5lUk50bzJ2bnl5UjFObE1aMEVDQXdFQUFhTldNRlF3RGdZRFZSMFBBUUgvQkFRREFnV2dNQk1HQTFVZEpRUU0KTUFvR0NDc0dBUVVGQndNQ01Bd0dBMVVkRXdFQi93UUNNQUF3SHdZRFZSMGpCQmd3Rm9BVVhKUkF4OG1tTlI3aQo1SUthSmdNTFdZWjNEWFl3RFFZSktvWklodmNOQVFFTEJRQURnZ0dCQUJCUDBDSXpDanRvQkhJNVlQYzJTOHlWCm4wKzU4czhXenR4UXU4Wk5IRFFzMUZ0SFNhRWkwdGREUE5kbGhOdXY3RkRKY2ViQk5JTVlzc2tZMzZad2ZaZ28KZis3WmduajJMMHF6MHJxZjlJa0IyRWFBdTlVQkRpWnNwblA5cGo4SFlFR29pUys0dHR5MXNzVm54WXUraDUvWgo2UENmbzZ2c2JoanBaTThuZjlRWVRNV1ZheG4wRnNvdjlpL21ySndCSHFwTzJVb1Uwa0oyakE0R25Nc3VST0YwCllDWHFqR3JrOTBqaWJLNms5aXFmNFRMWnBhcjFwUlRhQzBvUGhIcWVIYUNHWGtrSFRGQ3pkenFMQTlXQmh1UDUKTllJZUNHblJ1U2JmZE13VWR2VTZiWjM3L0ZxdWtFYWRTeGpWNHJJM2tOWExmRUZDb3hxYkt2VzJKcGYwcy8rdwp3cHZmNVRxc0crdjJvYW80VlMxaDBoTTNWdU9VMFlubFI5OXdZMFpXNkhwQm1FOVVJOHFtZlJ4b1VFQUJrcElQCm9UWUxqQUdhYXdPZ1lEMU04dkJZNU9rV3FKdTdCZWIxODA1dThDWEhUOWRqL1BKS2dZN01OUkhhQTNNb3llc0cKTk80TnZPaWViZkR1M1h0ZTlXVmx6UFYyNlFSMDFyR2NUTFFBRWZKZTZRPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBd0VtNjc5ZmtaemlkUGZOVUpRcGt4czdWakVraElhNlkzSjluRmc5L09VK1RuSm9EClBUcWx6aVdRNDBjbitZeVJkSFZORHE3aHBWRTI5QVhpSlBrSU5Tb3pZUkI4eFZ0VzNSeXErRGlVa0hRbGRvQ24KWTA3ZXZ2UFBPYW84OGJtUWordUlnUitzclFhUTU1R0J1bHZ5OUg2dDNMbUtyYUZENk1PbzlIRk9aQklNK1M1RApkTlJLU0tFd1cyZVZkZiszSXNTN1FBaUJ5dm01cHBJcENWTUJkRm5aYWR5YU1Ka2NHTEpHQ3hnR1ZlK245UGgvCk9DNlJEYjAwajRkdHhwdUpGczFNMlQxWGxvYnRZa2ROWTM2QWRxTjhPMnVXSzhra2l2Vm52cUR1aVdqMjdQSnYKUk1yU0dINE9LcjhGRUhoenRyMDE1RTIyamErZkxKSFUyVXhuUVFJREFRQUJBb0lCQUNlajY0QS9Vd3crZlJnRQozajltbGFEd2lkQ0tVT1MzTURjbk8yS3VYaTFyN01QWGNqeUFweWJJMHNZdjZKdEc4Y04rM1J4ZVRCRS9IV09RCkJPOVhVV3hZWDFBdXpISUpJdTZoVnRPbUltWm5NMFByUU5hMXJ6RFJaVkovZUdIaXZkMFZrc1gveUNMQlhFVUkKMTZRYUNZdUN4QWZoVGlmK08xZzBZZFBHdWdEaDVrRFh4ZVR1aEdKRmRCT3B0djBmYWh5c2Z0alNURnBXbUNKNAovcXZsOGllWTZuV3JwTDlseXFYZnNqK25VRjdNOTgwd2szM1I2VHI1bjVRVGhIOGFxRTRVVXdGRm9mZThXT1hLCmtJKzVnUW11WWhLQkROY2pyNlZFakY2am5teVhNS0NlRElqNTJuYkVqOFo2cjIxSEVqV2xjYmo0R2c0L3VFbkkKVXMxSGJpTUNnWUVBNGtTMlRYUnpjVlpLRkFWakt1Mi80RlZ4cWxLKzcyeU9icVZlK2kyMDVLZWFPRnpxOVRoeAp6Yi9PTXF3UG9JeDNsSS94eXVkS0pIUHYrMzI2NFBOOTRUeGhML0lIVXY4SThMSGJDTzRUT1cvclllQTVMeUJHClBaQ2lQS1czbTU0bGpkVlFnRXR4R2RHS09KTjFTZmlwV3BzcnFnY29oV2FySDg3TTM4bGo5L3NDZ1lFQTJZMzUKaXhubk8xUndOZUt1OEJVWDVyZUZ3djhPM2VtdUd0Mk9UV1VjK3JZTUYvVmhQZFZZUzdxdmg2akpueWFMdVI5TworcHM4ekR3UlN4MHFpQ3VxM25uNU1MaWZ5cmVIRWZtUVZDUnUzMlVYb0NsSThjTG10MUxzVUpVejJKaENLaytmCkNCSUt5RnlsMEcrdjNSRmdSNVZrcTRKUGtibVJRUE5td1N1a3pQTUNnWUEwdUZuWnRqWm53L2xDclBhc08vVW4KS2dGdjlCTzA2WkJPUzQzVHNPNmpFRUlvdTgyckVWbkMzTndJaG5xbHA5VDg4b1VlQjhJSXVGTEVRRWxZdktNcAo1YzJuUkRkY3FUdkdDVXJGeStNQzBRY0JLU05welpWUUp2RUdQSDZKYmRIR09GdW5hT3lUWFhWZE5VNXd5OVY1CjNRblJkaFdFNzZVVHBqV3FOdHhxSFFLQmdRQ0t0djdsRmFnZGFWSisyVUhIN1BzbmJkOEpIVTRpYXN4TGJ2YzgKRy91bFZBeFQvbTU1V1o0SjgwZldqT1c1NTM3eGs2ZnRIS3hnWVBCNTMyZnVHVUhDeHl6L1Jza0VIWTh2QTl4bAorakVEbWRhOWxYVmdTWENJZFlRZVFYUWtaN2pRZDZJa0tEVGQyazBUb1JNV051MFgxNGF2NE0vUlQrdnc2UUdjCnE3SlJ4d0tCZ0JEbTVqMUV2T2ZDWnBUVnFTS0QwUGp4L21aaDNLUWJpcXFFT005WjBybXI0QW14b2k0S2x0Uk4KQ2R2eDY0KzFFdmduUmVKdmdzVXhYZnZURjF6bXVzS3JQcjZNYVZQY0hiQlh0VEl5WjZwWjVrYnY4bXJ3L0NkTQpkalhkRFg3dDJiZUsycFJCSEhXUjdRRXphNzZkSFJ1cTBYeXJpbWxodzQ4T3pHZ0oxdlVQCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west1\n"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://34.140.223.163\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "cluster-uid",
              "value": "c0f5e27c315747198203f0e6fe9a0f718077710bb58145f588e137046f133d7a"
            },
            {
              "key": "cluster-location",
              "value": "europe-west1"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.62.160.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "gke3sa@gcpdiag-gke1-aaaa.iam.gserviceaccount.com",
            "scopes": [
              "https://www.googleapis.com/auth/cloud-platform"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke3-default-pool-8e8d9ac3",
      "kind": "compute#instanceTemplate"
    },
    {
      "id": "7019690673431402461",
      "creationTimestamp": "2021-12-06T02:42:58.310-08:00",
      "name": "gke-gke4-default-pool-fd15f71b",
      "description": "",
      "properties": {
        "tags": {
          "items": [
            "gke-gke4-5da39605-node"
          ]
        },
        "machineType": "e2-medium",
        "networkInterfaces": [
          {
            "network": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/networks/default",
            "subnetwork": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/regions/europe-west4/subnetworks/default",
            "name": "nic0",
            "aliasIpRanges": [
              {
                "ipCidrRange": "/24",
                "subnetworkRangeName": "gke-gke4-pods-5da39605"
              }
            ],
            "kind": "compute#networkInterface"
          }
        ],
        "disks": [
          {
            "type": "PERSISTENT",
            "mode": "READ_WRITE",
            "deviceName": "persistent-disk-0",
            "index": 0,
            "boot": true,
            "initializeParams": {
              "sourceImage": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1215-gke1302-cos-89-16108-534-8-v211021-c-pre",
              "diskSizeGb": "100",
              "diskType": "pd-standard",
              "labels": {
                "goog-gke-node": ""
              }
            },
            "autoDelete": true,
            "kind": "compute#attachedDisk"
          }
        ],
        "metadata": {
          "fingerprint": "ZcjPawzL8u8=",
          "items": [
            {
              "key": "user-data",
              "value": "#cloud-config\n\nwrite_files:\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      StandardOutput=journal+console\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: 0644\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: 0644\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            {
              "key": "gci-ensure-gke-docker",
              "value": "true"
            },
            {
              "key": "kube-env",
              "value": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=1060m,memory=1019Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMVENDQXBXZ0F3SUJBZ0lSQUlwakpNTE5UZzNyMGFaSTgxUU9COWN3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa1ptTm1ZelEwTTJNdE4yUm1NUzAwTVdJMUxUaGpPR010T0dOaVpHTTNOak5sTm1NMApNQ0FYRFRJeE1USXdOakE1TkRBMU4xb1lEekl3TlRFeE1USTVNVEEwTURVM1dqQXZNUzB3S3dZRFZRUURFeVJtClkyWmpORFF6WXkwM1pHWXhMVFF4WWpVdE9HTTRZeTA0WTJKa1l6YzJNMlUyWXpRd2dnR2lNQTBHQ1NxR1NJYjMKRFFFQkFRVUFBNElCandBd2dnR0tBb0lCZ1FDcnJFaVkreEZxVmo0eWdFeHpNU0VjcFhqdWt0cVlGbWdoQWhnegp6dVB4dW12NTBDSU1XeTVMTmdVbDh6dG5qWExHSUMvajFQMGRlTTYyWnNRbnF1M3JJa3drQUttaVEvSzVacXc5CmRRaEJQMUhvSzdkS0N3SWlCQlpWcXlNQnY0YmszU2hGVS9HYTBSZjkrdUcwWkUyOS9SR25zUWJsbGdocVl2K1IKNm1NNmFBbkdudVRDbWVGVkdwQnp1V0xpZ0lsVVorTG5OaWtDcU95ZW9rYXVGZ1pCc2s2MWNsMDlaYndwdk10bAo2UzQyUmgvSXNiRzU1UWkrZmlHVXBIdmlmbStyUW9TN2FNTDVQU3hLMEJZQkM3d3owUjNBK3h0Zks2WWFTQ1BUCmhJVmtjamQzUSt2aWRBME5ZS0lLR09MK1BXYmVKVW12Vk5xd3RVbkc1Q2hXZVQvclpjb0psZTIxZUJYc01tYngKUmcxakdBODZiYlZEMmZ5OTdseGZuS0tWbVFubnVlVUNXc1BXZFFjaVRMVU9DbkVMRllnZTFNYk9IYTQ1RFNocAp4S2RiZ3l1V3VKZFNhSlJLbTREWVhNV1kxODA3VkVzc2R5ZGgzczVwYXEwVXVObVkxQ2VrMm15ZnhBOUlpVmw4CjJ4YUpwUmp4a0JGL0Iza3JiL0UzN0E1bXZFa0NBd0VBQWFOQ01FQXdEZ1lEVlIwUEFRSC9CQVFEQWdJRU1BOEcKQTFVZEV3RUIvd1FGTUFNQkFmOHdIUVlEVlIwT0JCWUVGSUhvemtmdDAxVzQvTTlXbUZXSitOMmx1Y2pVTUEwRwpDU3FHU0liM0RRRUJDd1VBQTRJQmdRQkozTU9ZYzVzNE0yZmFHbG9kMjJ3U2tGVkZkQXdNeG1PSG1uOE44OGNOCkhlbS9qLzdpM01pOEg0M2djdENnZlZ2cW9KUlVEQzJZUHJHSVhpTEJEdE0rZ2lwL1pPL2JmQ1JjOFdkMjFVdjQKUnhtOHdRbFA3djRTQ0F5MnhvZTU5djVEdElnVnk2VTQrTk5TRkVRM1ZVVFRxUXpOa21XVUMrVUhHNWxjQ25UMwpMdWxkeGtkQjQ5MTJaZ2pCODFJZTFrc2JjQ0tOb1hHY1JlY1NOcTE0MnF0RC9FaDBOYUc0YUVvN2NuNGRuVkg5Cm1pTGNjTzlqS1V2QU9KQU53NlFJN2tQa2xhM2JsTnFKc2lCZlVvWk1tWjZybVRuOG0rclU2d0o0Z1FqbEVHdEgKeUVrekQrMG1jeE8yMmFTWjRoeit2bHdTN1llMEhxSXN4cHd2V3pITlpSbkxhN2Z1RmlzSzlMbUhhS2lsaWMwZwoyTjdIRkNxdFNTa0dPT09SMzhyYlVsMDRXWHRGWXU4M1ZaWkk0TUpJaFQzNnRqUWtRSHRXWWxaSGFqaUlhcXlyCjl3TmFSa2w0TW16REZzZXJMenNVMEhjT1BXKzN5NFltbktsMFc3eXpRR1dtMVJSZ2FzZGtoYkdjNnRlNTVCS3EKMmw0SHJqYU1BNFhCbDRMUURGYVVHNm89Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.56.0.0/14\nCLUSTER_NAME: gke4\nCNI_HASH: d7de11c3ed02f0a18496ba45eb677e3e254ace12848140246438d54fee6fe986131ad12721dcdd5fe4e0606409c0d6c91fdb42edd760fefa1f455677d552b1d9\nCNI_SHA1: b8ed4cefaac578d29c24de085dfe502ecd98ebb8\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.1\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.1\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.60.0.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2021-12-06T10:40:53+00:00\"\nEXEC_AUTH_PLUGIN_HASH: beb06bc613ac0446b296c20e21d518523ab495efc5a529926474979494bd35be0dbfe7d8d9c3299a120570a7101769710063cb4acac5eda4ee23afaab55dbf1a\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: b42adb3966c4295f17bf3c3f8a2058f4bda684b9\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/ca1e685df450fd5d32b57a659eb363b870b03937/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,RotateKubeletServerCertificate=true,ExecProbeTimeout=false\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-gke4-5da39605\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.60.0.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: d5aadfac834c5a07d01b25573fa903cfa2aa9bdd580f25c98fec2acd168d60246d7b18eeda6358beb179371b911a3c0af109734b265c294e5b9d9ab6df9277c7\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: 45fp9n3IUQGoapu1ic8Y2QPc-jTrWEZcKr7sPKQuEqA=\nKUBELET_ARGS: --v=2 --experimental-check-node-capabilities-before-mount=true --cloud-provider=gce\n  --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter --cert-dir=/var/lib/kubelet/pki/\n  --cni-bin-dir=/home/kubernetes/bin --kubeconfig=/var/lib/kubelet/kubeconfig --image-pull-progress-deadline=5m\n  --max-pods=110 --non-masquerade-cidr=0.0.0.0/0 --network-plugin=kubenet --volume-plugin-dir=/home/kubernetes/flexvolume\n  --node-status-max-images=25 --container-runtime=remote --container-runtime-endpoint=unix:///run/containerd/containerd.sock\n  --runtime-cgroups=/system.slice/containerd.service --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 10.0.1.2\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f0ed72a116a1e3c3e91ea4d1be745746b9a4cb87b0bc71570327beea5d55cd55e96777e503f8d04a13cf2f8b896c68cb1d00477c7a11d5084a8b64fe3f7af256\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.21.5-gke.1302/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.60.0.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURyRENDQWhTZ0F3SUJBZ0lSQUlVSm9MMTlEK2x4ZGZweDNKcDkwYTR3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa1ptTm1ZelEwTTJNdE4yUm1NUzAwTVdJMUxUaGpPR010T0dOaVpHTTNOak5sTm1NMApNQjRYRFRJeE1USXdOakV3TkRBMU4xb1hEVEkyTVRJd05URXdOREExTjFvd0hERWFNQmdHQTFVRUF4TVJhM1ZpClpXeGxkQzFpYjI5MGMzUnlZWEF3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRQ24KQ0Z4RVpXYkRRaTc1bkZ6YmhlYVFXWGQ0ZGVoT1BrN3k3VjRkaTA1U2twSkJHZGc1ZXFlS2FvQTZiR2NlUFNGbQowZ0daN0tDWVR5VjRTeFp0QmkwbktjSzNuenpma0VlN2dGVTAxZ3ovcXFuWTJheUxyT2QwRUJ5NS9BdGF5b2MxCjZhOXY5ME14TENlcEZDaFB0Y3VvSzNTTEpqQVBQbW0yMytWU2tHRFkxL2Jremp4aWxYK2JLTDV3RzJuTmJsdEkKRGUrYnRSVkRKQjRFK3JKSmdRL0JmUWZqeklISmxUSHdCc3drQVQvclROL2ljenRnUUVoakhobGFMZ2pjTnZRNAplR1FtaGI1aVFXNVVNRGtHR0JkUk1lc2JOMmFrcWFUM3lVWHhTaEVmQVB0K3VoM1RRb29MU3FDVnlzRDlXWkhOCjQvU0lTV3grVmM4S29Ob1RPZXBMQWdNQkFBR2pWakJVTUE0R0ExVWREd0VCL3dRRUF3SUZvREFUQmdOVkhTVUUKRERBS0JnZ3JCZ0VGQlFjREFqQU1CZ05WSFJNQkFmOEVBakFBTUI4R0ExVWRJd1FZTUJhQUZJSG96a2Z0MDFXNAovTTlXbUZXSitOMmx1Y2pVTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCZ1FDQTkwS2N4RlB0dk5la0UxVnBVMS9QCi9ITHJTRSt2MjlaL2FZZFZkbmN5aVVIZzM1OTdsSVNpZTExUHh1bTBYZCtSUSthTUVoem1vRjdSWnRVMzlvSUMKWXBGaE5ORitnRUlPbEdoaUoxTWJwMEdlQmluU0cyVStUUFMxeWRFNytzOVJ4VXZPL21NSlRYMnZJU1ZpcnMyOQppU2RvRHBMZVpqbncrcXpXTjhWWTJVMTQ2M2pqd3pBZU1laDM4bjhxTWtTY09TbWdKV0NudjBhSmw0Ujc2UElwClpzdlJ2dXdRUmNOOG1IckIzTnlSWnBMK2xKNXo5c2JEWmhwdm5zeW9BckJ2RlpRTzNtRjZheXZQUWxNNVhqOVcKZitQd0RpZTNpdHQ1WURBZFRyM0MrcXFrdnNTQjZmbDVaRFd3RlhtU2VRYTNPc2FvME9HWGpWc0l4SVJUb1VLUwpjSlhjNVFjRFppNFJHWksxMkExRVRKRjhVY3d0WXRVZFh4OEE2bEE5bjFmUkxya1RFUlFWWTJoN25ycHN1VXhkCkJOQTJCYXBJQ3FGZkx0TVdPdVVRelRNYzExckxPUHNNV21UZ01hakZZaksxYWhSRWJUQm80UHZzSlZlRDdXSVQKaFdpYlBrdmVzeFYvMVBTUTZVeC9nK2ErUzlYaUtubi9TVFYzdDVTLzFBZz0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBcHdoY1JHVm13MEl1K1p4YzI0WG1rRmwzZUhYb1RqNU84dTFlSFl0T1VwS1NRUm5ZCk9YcW5pbXFBT214bkhqMGhadElCbWV5Z21FOGxlRXNXYlFZdEp5bkN0NTg4MzVCSHU0QlZOTllNLzZxcDJObXMKaTZ6bmRCQWN1ZndMV3NxSE5lbXZiL2RETVN3bnFSUW9UN1hMcUN0MGl5WXdEejVwdHQvbFVwQmcyTmYyNU00OApZcFYvbXlpK2NCdHB6VzViU0Ezdm03VVZReVFlQlBxeVNZRVB3WDBINDh5QnlaVXg4QWJNSkFFLzYwemY0bk03CllFQklZeDRaV2k0STNEYjBPSGhrSm9XK1lrRnVWREE1QmhnWFVUSHJHemRtcEttazk4bEY4VW9SSHdEN2Zyb2QKMDBLS0MwcWdsY3JBL1ZtUnplUDBpRWxzZmxYUENxRGFFem5xU3dJREFRQUJBb0lCQUFFR3Z3Wms5eDFpb3RNTwowelUrZ3haNXg5d05WSjh5ZFdxN1VhaWhCQUY5U04vSHU1TVpQaVNCc1RscXJiUzdLVHJobkhmb1hKNUMrS09yCnNBdXdkRk9TeDJzRk9sNDZnZ2Z1TjZTZHhVdXRSNjlNSVlPWFp1VVZ4dzlwR2lyQ1dnYnc0VnRrRWhDR2xnZ3oKb3dIR1lYOTdKQk44eitJd0dIMlpGR2FPTFNpUmlXYTVxMDRDeXkvODRPM2pjVkRGM1BvTU11cFVmYzRaSGFOcgpCUDRJVlRYZGUzaDZYcnNOYUE2K1pMbTdYNW80Z09PSkE4NExBcEIwaWdtL3VIS09WZlJmYTVYWXdIVGxaREY2CmtDQjZxbDVvRi9IR3JEVTBxYlJDTnhVVG9xSnI4S3VxYXlEQUN6c0ZoZXZ5SVhWSzA4c2I4VUV6MksvcHVXeGwKQTAzejVaRUNnWUVBNHczS0F6RmtpVnRoMW5FcmVsU21sYXQ2Q09pUnBsOUtiRWtTWWJIRGpWYUtRNDMyeVM4YgpVVFhQd1FMVS8rV1E0RGJWd04vU3NrKzFjK0JZa1BqRlBKRHd3Ykkwa2FsUG5nbHp0REZuSWJpREhRQjNpVE96CjVHRGNhbTQ2cDZaUmdmK2JYdU5YT2ttQXRqbUcyUlpZeEFaL2kzeVpkTVJiUlNzL0FLTDhrRHNDZ1lFQXZGT3kKcEpONURXYVRxRUZTdU5yQnMzeXVQamZ2QjBhd21yTXBWMXlhZEY2dkNvcjBTdzU0SjdSRlBVVllhUGM4aUhOSgovQVc2RHJFZ1BrN1NuQ09JeVhMb3UrZGJXQXdnM09YZ2oxdFcyVk01U3lyeS9IcENpaWkrbllrV2xxSlhMZmg3CjRacHZLM3JmZ0lqYjFuZ2xERjkrbitEM2poanlRRThkNUlXSS9URUNnWUVBcW5pdTVJalFHQVRoUnpUKzFNRDcKdGNIaVJSQUFVdTZXblFpYjRYZXEvOUlxeXgrcVcxQ2Y3UEEvQklZUXovUlhPdEJRMnBmeHhHanVMb3NSVS85RApidjdQbEU0dEEvUWZ6K0wrMlJxQ2VTSGtad0R6dnJKdjdSY0FSblJ1VzNNWEhVaUJLZFA4cU1tSTlzZm9ROU53ClgvVVZDL0JIOHhCK0NrZTI3TTV5WEFNQ2dZRUF1ZlpEN3JNWTA1eTRyV3BqanRta2IrSHNCTkFpbmFLMS9PeHgKSkN6eTczb1hpbWVQdHhYQW5DUXNRc1pZK0wwNTd0czQ4VDJPYmJlRnlVRDRRdW5yeGxCTGRGQ09LREZCdWg3YwpVWEsySGI5S1VlbEZLdjVtK2hvbHIxV1JFb21YWUhOL2tGUjQ5Z3hNNnBVNXoxdXY2Ym5hUlhGVndlRHNSWWhhClVpOXlCK0VDZ1lFQXg5VFVNNkQ0K3FXRGR0N3VFRnZncUVVRkZudUtXRnRFUDQrZnp3VGdxODFNUGZpSk5QbVcKWDNLMzNuazBrWE43NmtEQjJHR1dLaEh0Z3h2dTAxSi9SeWE3Qi9EbnVDcm1mOWNRLzdIQW1xaUY5NzBUc0RsMQpUTUc3cStMVkdYbFMyZ29YZUZLdUo1eEtkSkJ5QVZUNFVrdUo2VnMxVnB3UGZwcnVkajAyTTFBPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: europe-west4-a\n"
            },
            {
              "key": "disable-legacy-endpoints",
              "value": "true"
            },
            {
              "key": "cluster-name",
              "value": "gke4"
            },
            {
              "key": "google-compute-enable-pcid",
              "value": "true"
            },
            {
              "key": "configure-sh",
              "value": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.8.7'\nDEFAULT_CNI_HASH='8f2cbee3b5f94d59f919054dccfe99a8e3db5473b553d91da8af4763e811138533e05df4dbeab16b3f774852b4184a7994968f5e036a3f531ad1ac4620d10ede'\n# when NPD version has a conflicts with OSS one, use GoB version\nDEFAULT_NPD_VERSION='v0.8.7'\nDEFAULT_NPD_HASH='853576423077bf72e7bd8e96cd782cf272f7391379f8121650c1448531c0d3a0991dfbd0784a1157423976026806ceb14ca8fb35bac1249127dbf00af45b7eea'\nDEFAULT_CRICTL_VERSION='v1.20.0'\nDEFAULT_CRICTL_HASH='bf6e07c0834ead3cb17342fdd684723acd66d71dbad9a93a2c2001db0af647db124be732d9eaa58e3d0f36d7ab1026ab1380e1331e084810f1403e3656d1205d'\nDEFAULT_MOUNTER_TAR_SHA='7956fd42523de6b3107ddc3ce0e75233d2fcb78436ff07a1389b6eaac91fb2b1b72a08f7a219eaf96ba1ca4da8d45271002e0d60e0644e796c665f99bb356516'\n###\n\n### Hardcoded ENABLE_LATEST_NPD, remove it when in OSS DEFAULT_NPD_VERSION is greater then v0.8.7\nENABLE_LATEST_NPD=\"true\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" && $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\nfunction download-kube-master-certs {\n  # Fetch kube-master-certs from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kube_master_certs=\"/tmp/kube-master-certs.yaml\"\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kube_master_certs}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-master-certs\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(${PYTHON} -c '''\nimport pipes,sys,yaml\n# check version of python and call methods appropriate for that version\nif sys.version_info[0] \u003c 3:\n    items = yaml.load(sys.stdin).iteritems()\nelse:\n    items = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs}\" \u003e \"${KUBE_HOME}/kube-master-certs\")\"\n    rm -f \"${tmp_kube_master_certs}\"\n  )\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] && [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | ${PYTHON} -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=$(get-metadata-value \"instance/attributes/is-master-node\")\n\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=$(get-metadata-value \"instance/attributes/enable_hms_read\")\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" && \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers\n      local curl_headers=\"\"\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] && valid-storage-scope ; then\n        curl_headers=\"Authorization: Bearer $(get-credentials)\"\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --max-time 300 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] && ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  local -r mounter_tar_sha=\"${DEFAULT_MOUNTER_TAR_SHA}\"\n  if is-preloaded \"mounter\" \"${mounter_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  download-or-bust \"${mounter_tar_sha}\" \"https://storage.googleapis.com/kubernetes-release/gci-mounter/mounter.tar\"\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  mv \"${KUBE_HOME}/mounter.tar\" /tmp/mounter.tar\n  tar xf /tmp/mounter.tar -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm /tmp/mounter.tar\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n  local -r npd_hash=\"${DEFAULT_NPD_HASH}\"\n  local -r npd_tar=\"node-problem-detector-${npd_version}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/kubernetes-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    local -r crictl_hash=\"${DEFAULT_CRICTL_HASH}\"\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/k8s-artifacts-cri-tools/release/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSES/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=$(get-metadata-value \"${hurl_gcs_att}\")\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=$(get-metadata-value \"${inplace_gcs_att}\")\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    retry-forever 30 ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e&1; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update && \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update && \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    && chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e&1; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e&1; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e&1; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" && -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # TODO: include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] && \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e&2\n      echo \"Supported platform(s): linux.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e&2\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e&2\n      echo \"Bailing out.\" \u003e&2\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#   $1    : delay between retries, in seconds.\n#   $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')\n  LOG_INSTANCE_NAME=$(hostname)\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\nlog-wrap 'DetectHostInfo' detect_host_info\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\nPYTHON=\"python\"\n\nlog-start 'SetPythonVersion'\nif [[ \"$(python -V 2\u003e&1)\" =~ \"Python 2\" ]]; then\n  # found python2, just use that\n  PYTHON=\"python\"\nelif [[ -f \"/usr/bin/python2.7\" ]]; then\n  # System python not defaulted to python 2 but using 2.7 during migration\n  PYTHON=\"/usr/bin/python2.7\"\nelse\n  # No python2 either by default, let's see if we can find python3\n  PYTHON=\"python3\"\n  if ! command -v ${PYTHON} \u003e/dev/null 2\u003e&1; then\n    echo \"ERROR Python not found. Aborting.\"\n    exit 2\n  fi\nfi\necho \"Version :  $(${PYTHON} -V 2\u003e&1)\"\nlog-end 'SetPythonVersion'\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\n# master certs\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n"
            },
            {
              "key": "cluster-uid",
              "value": "5da39605577f4754a6f44d49fc1e3b74c81e094d5c914236b85df65a745581be"
            },
            {
              "key": "gci-update-strategy",
              "value": "update_disabled"
            },
            {
              "key": "kubelet-config",
              "value": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.60.0.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 1060m\n  ephemeral-storage: 41Gi\n  memory: 1019Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n"
            },
            {
              "key": "kube-labels",
              "value": "cloud.google.com/gke-boot-disk=pd-standard,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-nodepool=default-pool,cloud.google.com/gke-os-distribution=cos,cloud.google.com/machine-family=e2"
            },
            {
              "key": "cluster-location",
              "value": "europe-west4-a"
            },
            {
              "key": "gci-metrics-enabled",
              "value": "true"
            },
            {
              "key": "kubeconfig",
              "value": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://10.0.1.2\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1alpha1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n"
            },
            {
              "key": "serial-port-logging-enable",
              "value": "true"
            }
          ],
          "kind": "compute#metadata"
        },
        "serviceAccounts": [
          {
            "email": "default",
            "scopes": [
              "https://www.googleapis.com/auth/devstorage.read_only",
              "https://www.googleapis.com/auth/logging.write",
              "https://www.googleapis.com/auth/monitoring",
              "https://www.googleapis.com/auth/service.management.readonly",
              "https://www.googleapis.com/auth/servicecontrol",
              "https://www.googleapis.com/auth/trace.append"
            ]
          }
        ],
        "scheduling": {
          "onHostMaintenance": "MIGRATE",
          "automaticRestart": true,
          "preemptible": false
        },
        "labels": {
          "goog-gke-node": ""
        },
        "shieldedInstanceConfig": {
          "enableSecureBoot": false,
          "enableVtpm": true,
          "enableIntegrityMonitoring": true
        }
      },
      "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates/gke-gke4-default-pool-fd15f71b",
      "kind": "compute#instanceTemplate"
    }
  ],
  "selfLink": "https://www.googleapis.com/compute/v1/projects/gcpdiag-gke1-aaaa/global/instanceTemplates",
  "kind": "compute#instanceTemplateList"
}
